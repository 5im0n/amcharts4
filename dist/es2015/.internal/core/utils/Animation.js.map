{"version":3,"file":"Animation.js","sourceRoot":"","sources":["../../../../../src/.internal/core/utils/Animation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { EventDispatcher, AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { registry } from \"../Registry\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t *\r\n\t * @type {Color | Percent | number | string | boolean}\r\n\t */\r\n\tfrom?: Color | Percent | number | string | boolean;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t *\r\n\t * @type {Color | Percent | number | string | boolean}\r\n\t */\r\n\tto: Color | Percent | number | string | boolean;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t *\r\n\t * @type {object}\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t *\r\n\t * @type {function}\r\n\t */\r\n\tupdateMethod?: (options: IAnimationOptions | IPercentAnimationOptions | IColorAnimationOptions, progress: number) => string | number | Color | Percent;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t * @type {any}\r\n\t */\r\n\tdummyData?:any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t *\r\n\t * @type {Percent}\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t *\r\n\t * @type {Percent}\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param  {number}     duration  Duration (ms)\r\n * @param  {function}   callback  Callback function\r\n * @return {IDisposer}            Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstart: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationend: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstop: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * Holds the list of currently playing animations.\r\n *\r\n * @ignore Exclude from docs\r\n * @type {Array<IAnimationObject>}\r\n */\r\nexport const animations: Array<IAnimationObject> = [];\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t *\r\n\t * @type {EventDispatcher<AMEvent<Animation, IAnimationEvents>>}\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Animation, IAnimationEvents>> = new EventDispatcher<AMEvent<Animation, IAnimationEvents>>();\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t *\r\n\t * @type {IAnimatable}\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t *\r\n\t * @type {IAnimationOptions[]}\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t * @type {(value: number) => number}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t *\r\n\t * @type {Optional<number>}\r\n\t */\r\n\tpublic progress: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Is this a frame-based animation?\r\n\t *\r\n\t * If the animation is frame-based, Animation will ensure that every frame\r\n\t * is played, regardless of time.\r\n\t *\r\n\t * If the animation is non-frame-based, it will play exactly the time set in\r\n\t * [[duration]].\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\tpublic frameBased: boolean = false;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t *\r\n\t * @type {IAnimationOptions[]}\r\n\t */\r\n\tprotected staticOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation duration in frames.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _frames: number = 0;\r\n\r\n\t/**\r\n\t * Current frame.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _frame: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t *\r\n\t * @type {IDisposer}\r\n\t */\r\n\tprotected _delayTimeout: $type.Optional<IDisposer>;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _time: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param {IAnimatable}                              object            An object animation should run on\r\n\t * @param {IAnimationOptions[] | IAnimationOptions}  animationOptions  One or several (array) of animation options\r\n\t * @param {number}                                   duration          Duration (ms)\r\n\t * @param {(number) => number}                       easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationend\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(animations, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param  {number}     delay  Delay (ms)\r\n\t * @return {Animation}         Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis._pause = true;\r\n\t\t\tthis._delayTimeout = this.setTimeout(this.start.bind(this), delay);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\t\tthis._frame = 1;\r\n\t\tthis._frames = registry.frameRate * this.duration / 1000;\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = this.getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[this.getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = this.getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = this.getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[this.getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstart\")) {\r\n\t\t\tthis.events.dispatchImmediately(\"animationstart\", {\r\n\t\t\t\ttype: \"animationstart\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param  {number}     count  Number of times to loop animation\r\n\t * @return {Animation}         Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._pause = false;\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tthis.pause();\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationend\")) {\r\n\t\t\tthis.events.dispatchImmediately(\"animationend\", {\r\n\t\t\t\ttype: \"animationend\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param  {boolean}    skipEvent  Do not trigger `animationstop` event\r\n\t * @return {Animation}             Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tthis.dispose();\r\n\t\t$array.remove(this.object.animations, this);\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstop\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstop\", {\r\n\t\t\t\t\ttype: \"animationstop\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns numeric value accoring to progress between start and end values.\r\n\t *\r\n\t * @param  {IAnimationOptions}  options   Option\r\n\t * @param  {number}             progress  Progress (0-1)\r\n\t * @return {number}                       Value according to progress\r\n\t */\r\n\tprotected getProgressNumber(options: IAnimationOptions, progress: number): number {\r\n\t\treturn <number>options.from + (<number>options.to - <number>options.from) * progress;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns [[Percent]] value accoring to progress between start and end\r\n\t * values.\r\n\t *\r\n\t * @param  {IPercentAnimationOptions}  options   Option\r\n\t * @param  {number}                    progress  Progress (0-1)\r\n\t * @return {number}                              Value according to progress\r\n\t */\r\n\tprotected getProgressPercent(options: IPercentAnimationOptions, progress: number): Percent {\r\n\t\treturn new Percent($type.getValue(options.from).percent + (options.to.percent - $type.getValue(options.from).percent) * progress);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns color value accoring to progress between start and end values.\r\n\t *\r\n\t * @param  {IAnimationOptions}  options   Option\r\n\t * @param  {number}             progress  Progress (0-1)\r\n\t * @return {string}                       Color according to progress\r\n\t */\r\n\tprotected getProgressColor(options: IColorAnimationOptions, progress: number): Color {\r\n\t\treturn new Color($colors.interpolate($type.getValue(options.from).rgb, options.to.rgb, progress));\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param {number} progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tlet value = options.updateMethod(options, progress);\r\n\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tif (this.frameBased) {\r\n\t\t\t\tprogress = this.easing(this._frame / this._frames);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\r\n\t\t\t\tprogress = this.easing(this._time / this.duration);\r\n\t\t\t\tif (this.duration == 0 || !$type.isNumber(progress)) {\r\n\t\t\t\t\tprogress = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif (this.frameBased) {\r\n\t\t\t\tthis._frame++;\r\n\r\n\t\t\t\tif (this._frame >= this._frames) {\r\n\t\t\t\t\tthis.end();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\t\tthis.end();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return {boolean} [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.stop(true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * [getHybridProperty description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param  {string}     property [description]\r\n\t * @param  {\"pixel\" |        \"relative\"}  type [description]\r\n\t * @return {string}              [description]\r\n\t */\r\n\tprivate getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\t\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n\t}\r\n\r\n}\r\n"]}