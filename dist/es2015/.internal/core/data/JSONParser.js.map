{"version":3,"file":"JSONParser.js","sourceRoot":"","sources":["../../../../../src/.internal/core/data/JSONParser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * JSON parser.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser, IDataParserOptions } from \"./DataParser\";\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Defines options for JSON format parser\r\n */\r\nexport interface IJSONOptions extends IDataParserOptions {\r\n\r\n\t/**\r\n\t * A list of fields that should be treaded as numeric.\r\n\t *\r\n\t * Any information container in such fields will be converted to `number`.\r\n\t *\r\n\t * @type {string[]}\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * A list of fields that hold date/time infromation.\r\n\t *\r\n\t * Parser will try to convert such fields into `Date` objects.\r\n\t *\r\n\t * @type {string[]}\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * A date formatted to be used when parsing dates.\r\n\t * \r\n\t * @type {DateFormatter}\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n}\r\n\r\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\r\nexport class JSONParser extends DataParser {\r\n\r\n\t/**\r\n\t * Tests if the data is valid JSON.\r\n\t * \r\n\t * @param  {string}   data  Source data\r\n\t * @return {boolean}        Is it JSON?\r\n\t */\r\n\tstatic isJSON(data: string): boolean {\r\n\t\ttry {\r\n\r\n\t\t\t// Try parsing JSON\r\n\t\t\tJSON.parse(data);\r\n\r\n\t\t\t// If we got to this point it means it's a valid JSON\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Content-type suitable for JSON format.\r\n\t * \r\n\t * @type {string}\r\n\t */\r\n\tpublic type: string = \"application/json\";\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IJSONOptions} for description of each option\r\n\t * @type {IJSONOptions}\r\n\t */\r\n\tpublic options: IJSONOptions = {};\r\n\r\n\t/**\r\n\t * Parses and returns data.\r\n\t * \r\n\t * @param  {string}  data  Unparsed data\r\n\t * @return {any}           Parsed data\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\r\n\t\t// Init return\r\n\t\tlet res: any;\r\n\r\n\t\t// Try parsing\r\n\t\ttry {\r\n\t\t\tif ($type.hasValue(JSON)) {\r\n\t\t\t\tres = JSON.parse(data);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tres = eval(data);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Do we need to cast some fields to numbers or dates?\r\n\t\tlet empty = $type.hasValue(this.options.emptyAs);\r\n\t\tlet numbers = this.parsableNumbers;\r\n\t\tlet dates = this.parsableDates;\r\n\t\tif (Array.isArray(res) && (numbers || dates || empty)) {\r\n\r\n\t\t\t// Iterate through the data and check if it needs to be converted\r\n\t\t\tfor (let i = 0, len = res.length; i < len; i++) {\r\n\t\t\t\tlet row = res[i];\r\n\t\t\t\t$object.each(row, (key, value) => {\r\n\t\t\t\t\tif (empty) {\r\n\t\t\t\t\t\trow[key] = this.maybeToEmpty(row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (numbers) {\r\n\t\t\t\t\t\trow[key] = this.maybeToNumber(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dates) {\r\n\t\t\t\t\t\trow[key] = this.maybeToDate(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Convert to array\r\n\t\t//return Array.isArray(res) ? res : [res];\r\n\t\treturn res;\r\n\r\n\t}\r\n\r\n}"]}