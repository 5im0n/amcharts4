{"version":3,"sources":["webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Projection.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapObject.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/Geo.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLine.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapUtils.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapImage.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapPolygon.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLineSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/SmallMap.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSpline.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapArc.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/ZoomControl.ts","webpack:///./map.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/map.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/types/MapChart.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLineObject.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapPolygonSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSplineSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapImageSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapArcSeries.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Mercator.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Miller.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Eckert6.ts","webpack:///C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Orthographic.ts"],"names":["__WEBPACK_IMPORTED_MODULE_2__Geo__","__webpack_require__","Projection","this","deltaLongitude","deltaLatitude","deltaGama","centerPoint","x","y","scale","prototype","projectGeoArea","geoArea","clippedGeoArea","clipGeoArea","convertGeoArea","projectGeoLine","geoLine","convertGeoLine","clipGeoLine","getClipRectangle1","longitude","latitude","getClipRectangle2","getRect1","north","south","west","east","getRect2","clippedLine","clipRectangle1","clipRectangle2","i","length","segment","clippedSegments","clipLine","concat","clippedSegments2","clippedArea","rect1","rect2","surface","hole","clippedAreas","surfaceRect","getExtremes","isInside","isOutside","push","clippedSurface1","clip","clippedHole1","clippedSurface2","clippedHole2","clippedAreas_1","__values","clippedAreas_1_1","next","done","area","value","convertedPoints","convertedAreaPoints","convertedSurface","s","point","convert","convertedHole","convertedSegmentPoints","geoPoint","rotate","pointInRadians","project","__WEBPACK_IMPORTED_MODULE_1__core_utils_Math__","invert","unproject","unrotate","lambda","phi","deltaGamma","deltaLambda","deltaPhi","cosDeltaPhi","Math","cos","sinDeltaPhi","sin","cosDeltaGamma","sinDeltaGamma","cosPhi","z","k","atan2","asin","subjectPolyline","clipPolygon","cp1","cp2","e","inside","p","intersection","dc","dp","n1","n2","n3","j","inputList","subjectPolygon","outputList","geoPoints","r1","r2","intermediatePoint","pointA","pointB","position","phi1","lambda1","phi2","lambda2","sinPhi1","cosPhi1","sinLambda1","cosLambda1","sinPhi2","cosPhi2","sinLambda2","cosLambda2","a","delta","sqrt","A","B","phi3","lambda3","__WEBPACK_IMPORTED_MODULE_0__core_System__","registeredClasses","__WEBPACK_IMPORTED_MODULE_4__core_utils_InterfaceColorSet__","MapSeriesDataItem","_super","_this","call","className","values","applyTheme","__extends","Object","defineProperty","setValue","updateExtremes","__WEBPACK_IMPORTED_MODULE_3__core_utils_Type__","__WEBPACK_IMPORTED_MODULE_0__series_Series__","MapSeries","isMeasured","minColor","getFor","nonScalingStroke","dataFields","createDataItem","validateData","__WEBPACK_IMPORTED_MODULE_2__core_utils_Iterator__","dataItems","iterator","dataItem","chart","validate","minValue","_prevMin","maxValue","_prevMax","dispatchImmediately","checkInclude","includes","excludes","id","indexOf","getPropertyValue","setPropertyValue","invalidateData","max","_maxValue","high","min","_minValue","low","processIncExc","handleObjectAdded","event","mapObject","newValue","parent","series","__WEBPACK_IMPORTED_MODULE_1__core_System__","MapObject","layout","clickable","readerTitle","itemReaderText","__WEBPACK_IMPORTED_MODULE_0__core_Container__","multiline","multiline_1","multiline_1_1","segment_1","segment_1_1","normalizePoint","__WEBPACK_IMPORTED_MODULE_0__core_utils_Math__","wrapAngleTo180","latitude180","abs","angle","__WEBPACK_IMPORTED_MODULE_10__Geo__","MapLine","line","__WEBPACK_IMPORTED_MODULE_4__core_elements_Polyline__","stroke","__WEBPACK_IMPORTED_MODULE_6__core_utils_Color__","strokeOpacity","interfaceColors","__WEBPACK_IMPORTED_MODULE_7__core_utils_InterfaceColorSet__","shortestDistance","positionToPoint","multiGeoLine","images","images_1","images_1_1","events","on","property","invalidate","imagesToConnect","_a","_b","image","newMultiGeoLine","newGeoLine","geoPointA","geoPointB","stepCount","d","projection","previousPoint","segments","_arrow","validatePosition","__WEBPACK_IMPORTED_MODULE_9__core_utils_Iterator__","lineObjects","measureElement","_lineObjects","__WEBPACK_IMPORTED_MODULE_3__core_utils_List__","__WEBPACK_IMPORTED_MODULE_1__MapLineObject__","handleLineObjectAdded","mapLineObject","mapLine","arrow","createChild","width","height","triangle","__WEBPACK_IMPORTED_MODULE_2__core_elements_Triangle__","fillOpacity","__WEBPACK_IMPORTED_MODULE_8__core_utils_Percent__","rotation","horizontalCenter","verticalCenter","copyFrom","source","clone","__WEBPACK_IMPORTED_MODULE_0__MapObject__","__WEBPACK_IMPORTED_MODULE_5__core_System__","multiPointToGeo","points","pointToGeo","multiPolygon","multiGeoArea","multiLine","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_2__core_utils_Type__","MapImage","moveTo","__WEBPACK_IMPORTED_MODULE_3__core_utils_InterfaceColorSet__","MapPolygon","polygon","__WEBPACK_IMPORTED_MODULE_1__core_elements_Polygon__","fill","tooltipPosition","multiGeoPolygon","fillRule","pixelWidth","pixelHeight","overflowX","overflowY","__WEBPACK_IMPORTED_MODULE_2__core_System__","__WEBPACK_IMPORTED_MODULE_7__core_utils_Iterator__","MapLineSeriesDataItem","_mapLine","component","mapLines","create","__WEBPACK_IMPORTED_MODULE_1__MapLine__","addSprite","_line","__WEBPACK_IMPORTED_MODULE_4__MapUtils__","_multiLine","_geoLine","_multiGeoLine","updateLineExtremes","__WEBPACK_IMPORTED_MODULE_0__MapSeries__","MapLineSeries","data","clear","getDataFromJSON","geoJSON","features","type","geometry","console","log","feature","id_1","this_1","include","exclude","coordinates","dataObject","__WEBPACK_IMPORTED_MODULE_5__core_utils_Array__","multiLineString","__WEBPACK_IMPORTED_MODULE_6__core_utils_Utils__","properties","moveValue","_mapLines","lineTemplate","createLine","__WEBPACK_IMPORTED_MODULE_2__core_utils_List__","__WEBPACK_IMPORTED_MODULE_3__core_System__","__WEBPACK_IMPORTED_MODULE_8__core_utils_InterfaceColorSet__","SmallMap","_chart","__WEBPACK_IMPORTED_MODULE_4__core_utils_Disposer__","align","valign","percentHeight","percentWidth","margin","background","moveToPosition","updateMapSize","__WEBPACK_IMPORTED_MODULE_2__MapSeries__","processSeries","seriesContainer","rectangle","__WEBPACK_IMPORTED_MODULE_1__core_elements_Rectangle__","strokeWidth","svgPoint","rectPoint","__WEBPACK_IMPORTED_MODULE_7__core_utils_Utils__","zoomLevel","svgPointToGeo","zoomToGeoPoint","get","set","updateRectangle","ceil","pixelX","pixelY","scaleRatio","afterDraw","maskRectangle","MapSpline","__WEBPACK_IMPORTED_MODULE_1__core_elements_Polyspline__","tensionX","tensionY","__WEBPACK_IMPORTED_MODULE_0__MapLine__","MapArc","__WEBPACK_IMPORTED_MODULE_1__core_elements_Polyarc__","ZoomControl","__WEBPACK_IMPORTED_MODULE_3__core_utils_Disposer__","padding","plusButton","__WEBPACK_IMPORTED_MODULE_1__core_elements_Button__","label","text","__WEBPACK_IMPORTED_MODULE_6__core_utils_Percent__","slider","handleBackgroundClick","updateThumbSize","thumb","draggable","handleThumbDrag","minusButton","role","readerLive","language","translate","fixLayout","undefined","marginTop","marginBottom","toFront","toBack","minX","maxX","minY","maxY","marginLeft","marginRight","sprite","target","spritePoint","maxPower","maxZoomLevel","LN2","minPower","minZoomLevel","power","pow","zoomGeoPoint","updateThumb","zoomOut","__WEBPACK_IMPORTED_MODULE_5__core_interaction_Interaction__","body","ev","topParent","hasFocused","__WEBPACK_IMPORTED_MODULE_4__core_utils_Keyboard__","isKey","isFocused","zoomIn","minHeight","visible","minWidth","isDown","step","createBackground","__WEBPACK_IMPORTED_MODULE_2__core_elements_RoundedRectangle__","__WEBPACK_IMPORTED_MODULE_7__core_System__","window","amcharts4","map","__WEBPACK_IMPORTED_MODULE_0__src_map__","__WEBPACK_IMPORTED_MODULE_35__internal_charts_map_Geo__","__WEBPACK_IMPORTED_MODULE_14__map_Geo__","MapChartDataItem","__WEBPACK_IMPORTED_MODULE_0__SerialChart__","MapChart","zoomDuration","zoomEasing","__WEBPACK_IMPORTED_MODULE_11__core_utils_Ease__","_prevZoomGeoPoint","__WEBPACK_IMPORTED_MODULE_4__map_projections_Projection__","inert","resizable","handleMapTransform","handleDoubleHit","chartContainer","udpateScaleRatio","chartContainerBg","dragStart","interactions","downPointers","getIndex","dragStop","focusable","handleWheel","handleMapDown","__WEBPACK_IMPORTED_MODULE_7__core_interaction_Interaction__","_zoomControl","__WEBPACK_IMPORTED_MODULE_6__core_utils_Keyboard__","getEventKey","pan","applyInternalDefaults","_mapAnimation","stop","__WEBPACK_IMPORTED_MODULE_10__core_utils_Utils__","htmlContainer","shift","__WEBPACK_IMPORTED_MODULE_12__core_utils_Iterator__","__WEBPACK_IMPORTED_MODULE_13__core_utils_Type__","westPoint","eastPoint","northPoint","southPoint","seriesWidth","seriesHeight","vScale","innerWidth","hScale","innerHeight","Infinity","dispatch","seriesPoint","seriesPointToGeo","geoPointToSVG","geoPointToSeries","_geoJSON","center","duration","__WEBPACK_IMPORTED_MODULE_9__core_utils_Math__","animate","to","pixelPaddingLeft","pixelPaddingTop","zoomToMapObject","__WEBPACK_IMPORTED_MODULE_2__map_MapImage__","__WEBPACK_IMPORTED_MODULE_3__map_MapPolygon__","zoomToRectangle","level","_prevZoomLevel","_smallMap","smallMap","__WEBPACK_IMPORTED_MODULE_5__map_SmallMap__","removeDispose","zoomControl","createSeries","__WEBPACK_IMPORTED_MODULE_1__map_MapSeries__","invalidateProjection","processConfig","config","createClassInstance","configOrder","b","asIs","field","__WEBPACK_IMPORTED_MODULE_8__core_System__","MapLineObject","adjustRotation","cloneChildren","__WEBPACK_IMPORTED_MODULE_9__core_utils_Colors__","MapPolygonSeriesDataItem","_mapPolygon","mapPolygons","_polygon","_multiPolygon","_geoPolygon","geoPolygon","_multiGeoPolygon","updateAreaExtremes","mapPolygon","MapPolygonSeries","__WEBPACK_IMPORTED_MODULE_8__core_utils_Type__","maxColor","percent","parsingStepDuration","clearPolygons","dispose","_parseDataFrom","_mapPolygons","polygonTemplate","__WEBPACK_IMPORTED_MODULE_1__MapPolygon__","template","getPolygonById","dataContext","MapSplineSeriesDataItem","__WEBPACK_IMPORTED_MODULE_1__MapSpline__","__WEBPACK_IMPORTED_MODULE_0__MapLineSeries__","MapSplineSeries","MapImageSeriesDataItem","_mapImage","mapImages","_point","__WEBPACK_IMPORTED_MODULE_5__MapUtils__","_geoPoint","mapImage","MapImageSeries","multiPoint","multiGeoPoint","__WEBPACK_IMPORTED_MODULE_4__core_utils_Array__","_mapImages","__WEBPACK_IMPORTED_MODULE_1__MapImage__","validateDataElement","MapArcSeriesDataItem","__WEBPACK_IMPORTED_MODULE_1__MapArc__","MapArcSeries","Mercator","atan","exp","PI","tan","__WEBPACK_IMPORTED_MODULE_0__Projection__","Miller","Eckert6","__WEBPACK_IMPORTED_MODULE_2__core_utils_Math__","Orthographic","prevPoint","i_1","extraPoints","splice","apply","__spread"],"mappings":"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","file":"map.js","sourcesContent":["/**\r\n * This module contains funcitonality related to geographical projections\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\nimport { IGeoRectangle } from \"../../../core/defs/IGeoRectangle\";\r\nimport { IPoint } from \"../../../core/defs/IPoint\";\r\nimport { system } from \"../../../core/System\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\nimport * as $type from \"../../../core/utils/Type\";\r\nimport * as $array from \"../../../core/utils/Array\";\r\nimport * as $geo from \"../Geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This is a base class for a geographical projection.\r\n */\r\nexport class Projection {\r\n\r\n\tpublic deltaLongitude: number = 0;\r\n\r\n\tpublic deltaLatitude: number = 0;\r\n\r\n\tpublic deltaGama: number = 0;\r\n\r\n\tpublic centerPoint: IPoint = { x: 0, y: 0 };\r\n\r\n\tpublic scale: number = 1;\r\n\r\n\tpublic projectGeoArea(geoArea: IGeoPoint[][][]): IPoint[][][] {\r\n\r\n\t\tlet clippedGeoArea: IGeoPoint[][][] = this.clipGeoArea(geoArea);\r\n\t\tlet convertedPoints: IPoint[][][] = this.convertGeoArea(clippedGeoArea);\r\n\r\n\t\treturn convertedPoints;\r\n\t}\r\n\r\n\tpublic projectGeoLine(geoLine: IGeoPoint[][]): IPoint[][] {\r\n\t\treturn this.convertGeoLine(this.clipGeoLine(geoLine));\r\n\t}\r\n\r\n\tpublic getClipRectangle1(): IGeoPoint[] {\r\n\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\r\n\t\tlet smallNum = 0.00001;\r\n\t\treturn [{ longitude: -180, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude + 90 }, { longitude: -180, latitude: latitude + 90 }];\r\n\t}\r\n\r\n\tpublic getClipRectangle2(): IGeoPoint[] {\r\n\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\r\n\t\tlet smallNum = 0.00001;\r\n\t\treturn [{ longitude: longitude + smallNum, latitude: -90 }, { longitude: 180, latitude: -90 }, { longitude: 180, latitude: 90 }, { longitude: longitude + smallNum, latitude: 90 }];\r\n\t}\r\n\r\n\tpublic getRect1(): IGeoRectangle {\r\n\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\r\n\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude - 180, east: longitude };\r\n\t}\r\n\r\n\tpublic getRect2(): IGeoRectangle {\r\n\t\tlet longitude = $geo.wrapAngleTo180(180 - this.deltaLongitude);\r\n\t\tlet latitude = $geo.wrapAngleTo180(this.deltaLatitude);\r\n\r\n\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude, east: (longitude + 180) };\r\n\t}\r\n\r\n\r\n\r\n\tprotected clipGeoLine(geoLine: IGeoPoint[][]): IGeoPoint[][] {\r\n\t\tif (!geoLine) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet clippedLine: IGeoPoint[][] = [];\r\n\r\n\t\tlet clipRectangle1 = this.getClipRectangle1();\r\n\t\tlet clipRectangle2 = this.getClipRectangle2();\r\n\r\n\t\tfor (let i: number = 0; i < geoLine.length; i++) {\r\n\t\t\tlet segment: IGeoPoint[] = geoLine[i];\r\n\r\n\t\t\tif (segment) {\r\n\t\t\t\tlet clippedSegments: IGeoPoint[][] = this.clipLine(segment, clipRectangle1);\r\n\t\t\t\tclippedLine = clippedLine.concat(clippedSegments);\r\n\r\n\t\t\t\tif(this.deltaLongitude != 0){\r\n\t\t\t\t\tlet clippedSegments2: IGeoPoint[][] = this.clipLine(segment, clipRectangle2);\r\n\t\t\t\t\tclippedLine = clippedLine.concat(clippedSegments2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn clippedLine;\r\n\t}\r\n\r\n\r\n\tprotected clipGeoArea(geoArea: IGeoPoint[][][]): IGeoPoint[][][] {\r\n\r\n\t\tif (!geoArea) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet clippedArea: IGeoPoint[][][] = [];\r\n\r\n\t\tlet clipRectangle1 = this.getClipRectangle1();\r\n\t\tlet clipRectangle2 = this.getClipRectangle2();\r\n\r\n\t\tlet rect1 = this.getRect1();\r\n\t\tlet rect2 = this.getRect2();\r\n\r\n\t\tfor (let i: number = 0; i < geoArea.length; i++) {\r\n\r\n\t\t\tlet surface: IGeoPoint[] = geoArea[i][0];\r\n\t\t\tlet hole: IGeoPoint[] = geoArea[i][1];\r\n\r\n\t\t\tlet clippedAreas: IGeoPoint[][][] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet surfaceRect = this.getExtremes(surface);\r\n\r\n\t\t\t\tif (!this.isInside(surfaceRect, rect1) && !this.isOutside(surfaceRect, rect1)) {\r\n\t\t\t\t\tlet clippedSurface1: IGeoPoint[] = this.clip(surface, clipRectangle1);\r\n\t\t\t\t\tlet clippedHole1: IGeoPoint[] = this.clip(hole, clipRectangle1);\r\n\t\t\t\t\tclippedAreas.push([clippedSurface1, clippedHole1]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tclippedAreas.push([surface, hole]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!this.isInside(surfaceRect, rect2) && !this.isOutside(surfaceRect, rect2)) {\r\n\t\t\t\t\tlet clippedSurface2: IGeoPoint[] = this.clip(surface, clipRectangle2);\r\n\t\t\t\t\tlet clippedHole2: IGeoPoint[] = this.clip(hole, clipRectangle2);\r\n\t\t\t\t\tclippedAreas.push([clippedSurface2, clippedHole2]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let area of clippedAreas) {\r\n\t\t\t\tclippedArea.push(area);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn clippedArea;\r\n\t}\r\n\r\n\tprotected convertGeoArea(geoArea: IGeoPoint[][][]): IPoint[][][] {\r\n\r\n\t\tif (!geoArea) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet convertedPoints: IPoint[][][] = [];\r\n\r\n\t\tfor (let i: number = 0; i < geoArea.length; i++) {\r\n\r\n\t\t\tlet surface: IGeoPoint[] = geoArea[i][0];\r\n\t\t\tlet hole: IGeoPoint[] = geoArea[i][1];\r\n\r\n\t\t\tlet convertedAreaPoints: IPoint[][] = [];\r\n\r\n\t\t\tif (surface) {\r\n\t\t\t\tlet convertedSurface: IPoint[] = [];\r\n\r\n\t\t\t\tfor (let s: number = 0; s < surface.length; s++) {\r\n\t\t\t\t\tlet point: IPoint = this.convert(surface[s]);\r\n\r\n\t\t\t\t\tconvertedSurface.push(point);\r\n\t\t\t\t}\r\n\t\t\t\tconvertedAreaPoints.push(convertedSurface);\r\n\t\t\t}\r\n\r\n\t\t\tif (hole) {\r\n\t\t\t\tlet convertedHole: IPoint[] = [];\r\n\t\t\t\tfor (let s: number = 0; s < hole.length; s++) {\r\n\t\t\t\t\tlet point: IPoint = this.convert(hole[s]);\r\n\r\n\t\t\t\t\tconvertedHole.push(point);\r\n\t\t\t\t}\r\n\t\t\t\tconvertedAreaPoints.push(convertedHole);\r\n\t\t\t}\r\n\t\t\tconvertedPoints.push(convertedAreaPoints);\r\n\t\t}\r\n\t\treturn convertedPoints;\r\n\t}\r\n\r\n\tprotected convertGeoLine(geoLine: IGeoPoint[][]): IPoint[][] {\r\n\t\tif (!geoLine) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet convertedPoints: IPoint[][] = [];\r\n\r\n\t\tfor (let i: number = 0; i < geoLine.length; i++) {\r\n\r\n\t\t\tlet segment: IGeoPoint[] = geoLine[i];\r\n\r\n\t\t\tlet convertedSegmentPoints: IPoint[] = [];\r\n\r\n\t\t\tfor (let s: number = 0; s < segment.length; s++) {\r\n\t\t\t\tlet geoPoint: IGeoPoint = segment[s];\r\n\r\n\t\t\t\tlet point: IPoint = this.convert(geoPoint);\r\n\t\t\t\tconvertedSegmentPoints.push(point);\r\n\t\t\t}\r\n\r\n\t\t\tconvertedPoints.push(convertedSegmentPoints);\r\n\t\t}\r\n\t\treturn convertedPoints;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a geographical point (lat/long) to a screen point (x/y)\r\n\t * @param  {IGeoPoint} geoPoint Geo point (lat/long)\r\n\t * @return {IPoint}             Screen point (x/y)\r\n\t */\r\n\tpublic convert(geoPoint: IGeoPoint): IPoint {\r\n\t\tgeoPoint = $geo.normalizePoint(geoPoint);\r\n\t\tgeoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\tlet pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n\t\treturn {\r\n\t\t\tx: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 2) * this.scale,\r\n\t\t\ty: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 2) * this.scale\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a screen point (x/y) to a geographical point (lat/long)\r\n\t * @param  {IPoint}    point Screen point (x/y)\r\n\t * @return {IGeoPoint}       Geo point (lat/long)\r\n\t */\r\n\tpublic invert(point: IPoint): IGeoPoint {\r\n\t\tlet pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n\r\n\t\tlet geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n\r\n\t\tgeoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\r\n\t\treturn geoPoint;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns X/Y coordinates.\r\n\t * Individual projections will override this method to apply their own \r\n\t * projection logic.\r\n\t * @param  {number} lambda [description]\r\n\t * @param  {number} phi    [description]\r\n\t * @return {IPoint}        X/Y coordinates\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn { x: lambda, y: phi };\r\n\t}\r\n\r\n\t/**\r\n\t * Returns geographical coordinates (lat/long).\r\n\t * Individual projections will override this method to apply their own \r\n\t * projection logic.\r\n\t * @param  {number}    x X coordinate\r\n\t * @param  {number}    y Y coordinate\r\n\t * @return {IGeoPoint}   Geographical point\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn { longitude: x, latitude: y };\r\n\t}\r\n\r\n\r\n\trotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaPhi + x * sinDeltaPhi;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma) };\r\n\t}\r\n\r\n\tunrotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaGamma - y * sinDeltaGamma;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi) };\r\n\t}\r\n\r\n\r\n\r\n\tclipLine(subjectPolyline: IGeoPoint[], clipPolygon: IGeoPoint[]): IGeoPoint[][] {\r\n\r\n\t\tif (!subjectPolyline || subjectPolyline.length == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet cp1: IGeoPoint;\r\n\t\tlet cp2: IGeoPoint;\r\n\r\n\t\tvar inside = function(p: IGeoPoint) {\r\n\t\t\treturn (cp2.longitude - cp1.longitude) * (p.latitude - cp1.latitude) > (cp2.latitude - cp1.latitude) * (p.longitude - cp1.longitude);\r\n\t\t};\r\n\r\n\t\tlet s: IGeoPoint;\r\n\t\tlet e: IGeoPoint;\r\n\r\n\t\t//@todo: make a separate function\r\n\t\tvar intersection = function() {\r\n\t\t\tlet dc = { longitude: cp1.longitude - cp2.longitude, latitude: cp1.latitude - cp2.latitude };\r\n\t\t\tlet dp = { longitude: s.longitude - e.longitude, latitude: s.latitude - e.latitude };\r\n\t\t\tlet n1 = cp1.longitude * cp2.latitude - cp1.latitude * cp2.longitude;\r\n\t\t\tlet n2 = s.longitude * e.latitude - s.latitude * e.longitude;\r\n\t\t\tlet n3 = 1.0 / (dc.longitude * dp.latitude - dc.latitude * dp.longitude);\r\n\r\n\t\t\treturn { longitude: (n1 * dp.longitude - n2 * dc.longitude) * n3, latitude: (n1 * dp.latitude - n2 * dc.latitude) * n3 };\r\n\t\t};\r\n\r\n\t\tlet segments: IGeoPoint[][] = []\r\n\t\tvar segment: IGeoPoint[] = subjectPolyline;\r\n\r\n\t\tcp1 = clipPolygon[clipPolygon.length - 1];\r\n\r\n\t\tfor (let j in clipPolygon) {\r\n\t\t\tcp2 = clipPolygon[j];\r\n\t\t\tlet inputList = segment;\r\n\t\t\tsegment = [];\r\n\t\t\ts = inputList[0];\r\n\t\t\tfor (let i = 0; i < inputList.length; i++) {\r\n\t\t\t\te = inputList[i];\r\n\r\n\t\t\t\tif (inside(e)) {\r\n\t\t\t\t\tif (!inside(s)) {\r\n\t\t\t\t\t\tsegment.push(intersection());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsegment.push(e);\r\n\t\t\t\t}\r\n\t\t\t\telse if (inside(s)) {\r\n\t\t\t\t\tsegment.push(intersection());\r\n\t\t\t\t}\r\n\r\n\t\t\t\ts = e;\r\n\t\t\t}\t\t\t\r\n\t\t\tcp1 = cp2;\r\n\t\t}\r\n\r\n\t\treturn [segment];\r\n\t}\r\n\r\n\r\n\r\n\r\n\t//@todo add credits to roseta code\r\n\t//@todo: someday make it better\r\n\tclip(subjectPolygon: IGeoPoint[], clipPolygon: IGeoPoint[]) {\r\n\r\n\t\tif (!subjectPolygon || subjectPolygon.length == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet cp1: IGeoPoint;\r\n\t\tlet cp2: IGeoPoint;\r\n\r\n\t\tvar inside = function(p: IGeoPoint) {\r\n\t\t\treturn (cp2.longitude - cp1.longitude) * (p.latitude - cp1.latitude) > (cp2.latitude - cp1.latitude) * (p.longitude - cp1.longitude);\r\n\t\t};\r\n\r\n\t\tlet s: IGeoPoint;\r\n\t\tlet e: IGeoPoint;\r\n\t\t//@todo: make a separate function\r\n\t\tvar intersection = function() {\r\n\t\t\tlet dc = { longitude: cp1.longitude - cp2.longitude, latitude: cp1.latitude - cp2.latitude };\r\n\t\t\tlet dp = { longitude: s.longitude - e.longitude, latitude: s.latitude - e.latitude };\r\n\t\t\tlet n1 = cp1.longitude * cp2.latitude - cp1.latitude * cp2.longitude;\r\n\t\t\tlet n2 = s.longitude * e.latitude - s.latitude * e.longitude;\r\n\t\t\tlet n3 = 1.0 / (dc.longitude * dp.latitude - dc.latitude * dp.longitude);\r\n\r\n\t\t\treturn { longitude: (n1 * dp.longitude - n2 * dc.longitude) * n3, latitude: (n1 * dp.latitude - n2 * dc.latitude) * n3 };\r\n\t\t};\r\n\r\n\t\tvar outputList = subjectPolygon;\r\n\r\n\t\tcp1 = clipPolygon[clipPolygon.length - 1];\r\n\r\n\t\tfor (let j in clipPolygon) {\r\n\t\t\tcp2 = clipPolygon[j];\r\n\t\t\tlet inputList = outputList;\r\n\t\t\toutputList = [];\r\n\t\t\ts = inputList[inputList.length - 1]; //last on the input list\r\n\t\t\tfor (let i in inputList) {\r\n\t\t\t\te = inputList[i];\r\n\r\n\t\t\t\tif (inside(e)) {\r\n\t\t\t\t\tif (!inside(s)) {\r\n\t\t\t\t\t\toutputList.push(intersection());\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutputList.push(e);\r\n\t\t\t\t}\r\n\t\t\t\telse if (inside(s)) {\r\n\t\t\t\t\toutputList.push(intersection());\r\n\t\t\t\t}\r\n\t\t\t\ts = e;\r\n\t\t\t}\r\n\t\t\tcp1 = cp2;\r\n\t\t}\r\n\t\treturn outputList;\r\n\t}\r\n\r\n\t//@todo: move to some utils?\r\n\tpublic getExtremes(geoPoints: IGeoPoint[]): IGeoRectangle {\r\n\r\n\t\tlet west: number = geoPoints[0].longitude;\r\n\t\tlet east: number = geoPoints[0].longitude;\r\n\t\tlet north: number = geoPoints[0].latitude;\r\n\t\tlet south: number = geoPoints[0].latitude;\r\n\r\n\t\tfor (let s: number = 0; s < geoPoints.length; s++) {\r\n\t\t\tlet longitude: number = geoPoints[s].longitude;\r\n\t\t\tlet latitude: number = geoPoints[s].latitude;\r\n\r\n\t\t\tif ((west > longitude)) {\r\n\t\t\t\twest = longitude;\r\n\t\t\t}\r\n\t\t\tif ((east < longitude)) {\r\n\t\t\t\teast = longitude;\r\n\t\t\t}\r\n\r\n\t\t\tif ((north < latitude)) {\r\n\t\t\t\tnorth = latitude;\r\n\t\t\t}\r\n\t\t\tif ((south > latitude)) {\r\n\t\t\t\tsouth = latitude;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { north: north, east: east, south: south, west: west };\r\n\t}\r\n\r\n\t//@todo: move to some utils?\r\n\tpublic isInside(r1: IGeoRectangle, r2: IGeoRectangle) {\r\n\t\tif (r1.north < r2.north && r1.south > r2.south && r1.west > r2.west && r1.east < r2.east) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//@todo: move to some utils?\r\n\tpublic isOutside(r1: IGeoRectangle, r2: IGeoRectangle) {\r\n\t\tif (r1.south > r2.north || r1.north < r2.south || r1.west > r2.east || r1.east < r2.west) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t//@todo: move to some utils?\r\n\t//@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\r\n\tpublic intermediatePoint(pointA: IGeoPoint, pointB: IGeoPoint, position: number) {\r\n\t\tvar phi1 = pointA.latitude * $math.RADIANS;\r\n\t\tlet lambda1 = pointA.longitude * $math.RADIANS;\r\n\r\n\t\tlet phi2 = pointB.latitude * $math.RADIANS;\r\n\t\tlet lambda2 = pointB.longitude * $math.RADIANS;\r\n\r\n\t\tvar sinPhi1 = Math.sin(phi1);\r\n\t\tlet cosPhi1 = Math.cos(phi1);\r\n\t\tlet sinLambda1 = Math.sin(lambda1);\r\n\t\tlet cosLambda1 = Math.cos(lambda1);\r\n\t\tvar sinPhi2 = Math.sin(phi2);\r\n\t\tlet cosPhi2 = Math.cos(phi2);\r\n\t\tlet sinLambda2 = Math.sin(lambda2);\r\n\t\tlet cosLambda2 = Math.cos(lambda2);\r\n\r\n\t\t// distance between points\r\n\t\tvar deltaPhi = phi2 - phi1;\r\n\t\tvar deltaLambda = lambda2 - lambda1;\r\n\t\tvar a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\r\n\t\tvar delta = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n\t\tvar A = Math.sin((1 - position) * delta) / Math.sin(delta);\r\n\t\tvar B = Math.sin(position * delta) / Math.sin(delta);\r\n\r\n\t\tvar x = A * cosPhi1 * cosLambda1 + B * cosPhi2 * cosLambda2;\r\n\t\tvar y = A * cosPhi1 * sinLambda1 + B * cosPhi2 * sinLambda2;\r\n\t\tvar z = A * sinPhi1 + B * sinPhi2;\r\n\r\n\t\tvar phi3 = Math.atan2(z, Math.sqrt(x * x + y * y));\r\n\t\tvar lambda3 = Math.atan2(y, x);\r\n\r\n\t\treturn { latitude: phi3 * $math.DEGREES, longitude: lambda3 * $math.DEGREES };\r\n\t};\r\n}\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"Projection\"] = Projection;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Projection.ts","/**\r\n * Map series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Series, SeriesDataItem, ISeriesProperties, ISeriesDataFields, ISeriesAdapters, ISeriesEvents } from \"../series/Series\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapObject } from \"./MapObject\";\r\nimport { MapPolygon } from \"./MapPolygon\";\r\nimport { IListEvents, ListTemplate } from \"../../core/utils/List\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport { Container } from \"../../core/Container\";\r\nimport { IMapDataObject, IMapPolygonDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Color } from \"../../core/utils/Color\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapSeries]].\r\n * \r\n * @see {@link DataItem}\r\n */\r\nexport class MapSeriesDataItem extends SeriesDataItem {\r\n\r\n\t/**\r\n\t * Longitude of the East-most point of the element.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic east: number;\r\n\r\n\t/**\r\n\t * Longitude of the West-most point of the element.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic west: number;\r\n\r\n\t/**\r\n\t * Latitude of the South-most point of the element.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic south: number;\r\n\r\n\t/**\r\n\t * Latitude of the North-most point of the element.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic north: number;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t *\r\n\t * @type {Component}\r\n\t */\r\n\tpublic _component: MapSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSeriesDataItem\";\r\n\t\tthis.values.value = {};\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Numeric value of the data item.\r\n\t *\r\n\t * Value may be used in heat-map calculations.\r\n\t *\r\n\t * @param {number}  value  Value\r\n\t */\r\n\tpublic set value(value: number) {\r\n\t\tthis.setValue(\"value\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} Value\r\n\t */\r\n\tpublic get value(): number {\r\n\t\treturn this.values.value.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the item's bounding coordinates: coordinates of the East, West,\r\n\t * North, and South-most points.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {IGeoPoint[]}  geoPoints  Points of the element\r\n\t */\r\n\tpublic updateExtremes(geoPoints: IGeoPoint[]): void {\r\n\t\tfor (let s: number = 0; s < geoPoints.length; s++) {\r\n\t\t\tlet longitude: number = geoPoints[s].longitude;\r\n\t\t\tlet latitude: number = geoPoints[s].latitude;\r\n\r\n\t\t\tif ((this.west > longitude) || !$type.isNumber(this.west)) {\r\n\t\t\t\tthis.west = longitude;\r\n\t\t\t}\r\n\t\t\tif ((this.east < longitude) || !$type.isNumber(this.east)) {\r\n\t\t\t\tthis.east = longitude;\r\n\t\t\t}\r\n\r\n\t\t\tif ((this.north < latitude) || !$type.isNumber(this.north)) {\r\n\t\t\t\tthis.north = latitude;\r\n\t\t\t}\r\n\t\t\tif ((this.south > latitude) || !$type.isNumber(this.south)) {\r\n\t\t\t\tthis.south = latitude;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * [GEOJSONGeometry description]\r\n * \r\n * @type {string}\r\n * @todo Description\r\n */\r\nexport type GEOJSONGeometry = \"Point\" | \"LineString\" | \"Polygon\" | \"MultiPoint\" | \"MultiLineString\" | \"MultiPolygon\";\r\n\r\n/**\r\n * Defines data fields for [[MapSeries]].\r\n *\r\n * @todo Alllow any number of values?\r\n */\r\nexport interface IMapSeriesDataFields extends ISeriesDataFields {\r\n\r\n\t/**\r\n\t * A field number in data for a numeric value of the map object.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tvalue?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[MapSeries]].\r\n */\r\nexport interface IMapSeriesProperties extends ISeriesProperties {\r\n\r\n\t/**\r\n\t * A color to apply to map objects with the lowest value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tminColor?: Color;\r\n\r\n\t/**\r\n\t * A color to apply to map objects with the highest value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tmaxColor?: Color;\r\n\r\n\t/**\r\n\t * A flag telling if the series should get data from geoJSON or not\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\tgetDataFromJSON?: boolean;\r\n\r\n\t/**\r\n\t * A list of object ids to include from the series.\r\n\t *\r\n\t * @type {string[]}\r\n\t */\r\n\tinclude?: string[];\r\n\r\n\t/**\r\n\t * A list of object ids to exclude from the series.\r\n\t *\r\n\t * @type {string[]}\r\n\t */\r\n\texclude?: string[];\r\n}\r\n\r\n/**\r\n * Defines events for [[MapSeries]].\r\n */\r\nexport interface IMapSeriesEvents extends ISeriesEvents { \r\n\t/**\r\n\t * Invoked when minValue or maxValue changes\r\n\t */\r\n\tvalueextremeschanged: {};\t\r\n}\r\n\r\n/**\r\n * Defines adapters for [[MapSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapSeriesAdapters extends ISeriesAdapters, IMapSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A base class for series of map objects.\r\n *\r\n * @see {@link IMapSeriesEvents} for a list of available Events\r\n * @see {@link IMapSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapSeries extends Series {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t *\r\n\t * @type {SpriteEventDispatcher<AMEvent<MapSeries, IMapSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapSeries, IMapSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapSeriesDataItem;\r\n\r\n\t/**\r\n\t * The longitude of the East-most point in the series. (out of all elements)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic east: number;\r\n\r\n\t/**\r\n\t * The longitude of the West-most point in the series. (out of all elements)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic west: number;\r\n\r\n\t/**\r\n\t * The latitude of the South-most point in the series. (out of all elements)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic south: number;\r\n\r\n\t/**\r\n\t * The latitude of the North-most point in the series. (out of all elements)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic north: number;\r\n\r\n\t/**\r\n\t * A related chart/map object, this element is drawn on.\r\n\t *\r\n\t * @type {MapChart}\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\t/**\r\n\t * User-defined lowest value in the series.\r\n\t * @ignore\r\n\t * @type {number}\r\n\t */\r\n\tprotected _minValue: number;\r\n\r\n\t/**\r\n\t * User-defined heighest value in the series.\r\n\t * @ignore\r\n\t * @type {number}\r\n\t */\r\n\tprotected _maxValue: number;\r\n\r\n\t/**\r\n\t * previous min value\r\n\t * @ignore\r\n\t * @type {number}\r\n\t */\r\n\tprotected _prevMin: number;\r\n\r\n\t/**\r\n\t * previous max value\r\n\t * @ignore\r\n\t * @type {number}\r\n\t */\r\n\tprotected _prevMax: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSeries\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.minColor = new InterfaceColorSet().getFor(\"background\");\r\n\t\tthis.nonScalingStroke = true;\r\n\r\n\t\t// Set data fields\r\n\t\tthis.dataFields.value = \"value\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return {MapSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates series data, effectively causing the whole series to be\r\n\t * redrawn.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tsuper.validateData();\r\n\t\t$iter.each(this.dataItems.iterator(), (dataItem) => {\r\n\t\t\tif ((this.west > dataItem.west) || !$type.isNumber(this.west)) {\r\n\t\t\t\tthis.west = dataItem.west;\r\n\t\t\t}\r\n\t\t\tif ((this.east < dataItem.east) || !$type.isNumber(this.east)) {\r\n\t\t\t\tthis.east = dataItem.east;\r\n\t\t\t}\r\n\r\n\t\t\tif ((this.north < dataItem.north) || !$type.isNumber(this.north)) {\r\n\t\t\t\tthis.north = dataItem.north;\r\n\t\t\t}\r\n\t\t\tif ((this.south > dataItem.south) || !$type.isNumber(this.south)) {\r\n\t\t\t\tthis.south = dataItem.south;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.chart.updateExtremes();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the series\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tif (this.minValue != this._prevMin || this.maxValue != this._prevMax) {\r\n\t\t\tthis.dispatchImmediately(\"valueextremeschanged\");\r\n\t\t\tthis._prevMin = this.minValue;\r\n\t\t\tthis._prevMax = this.maxValue;\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether object should be included in series.\r\n\t *\r\n\t * @param  {string[]}  includes  A list of explicitly included ids\r\n\t * @param  {string[]}  excludes  A list of explicitly excluded ids\r\n\t * @param  {string}    id        Id of the object\r\n\t * @return {boolean}             Include?\r\n\t */\r\n\tprotected checkInclude(includes: string[], excludes: string[], id: string): boolean {\r\n\t\tif (includes) {\r\n\t\t\tif (includes.length == 0) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (includes.indexOf(id) == -1) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (excludes && excludes.length > 0) {\r\n\t\t\tif (excludes.indexOf(id) != -1) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Should the map extract all the data about element, such as title, from\r\n\t * GeoJSON format?\r\n\t * @todo: review description, this is more about polygons/lines/points and not about titles. if a mapPolygonSeries doesn't have this set to true, it won't show any areas unless you pass data directly to the series\r\n\t *\r\n\t * @param {boolean}  value  Use GeoJSON data?\r\n\t */\r\n\tpublic set getDataFromJSON(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"getDataFromJSON\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return {boolean} Use GeoJSON data?\r\n\t */\r\n\tpublic get getDataFromJSON(): boolean {\r\n\t\treturn this.getPropertyValue(\"getDataFromJSON\");\r\n\t}\r\n\r\n\t/**\r\n\t * Color for the lowest value in a heat map.\r\n\t *\r\n\t * In heat map, each object will be colored with an intermediate color\r\n\t * between `minColor` and `maxColor` based on their `value` position between\r\n\t * `min` and `max`.\r\n\t *\r\n\t * @param {Color}  value  Lowest color\r\n\t */\r\n\tpublic set minColor(value: Color) {\r\n\t\tthis.setPropertyValue(\"minColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Color} Lowest color\r\n\t */\r\n\tpublic get minColor(): Color {\r\n\t\treturn this.getPropertyValue(\"minColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * Color for the highest value in a heat map.\r\n\t *\r\n\t * In heat map, each object will be colored with an intermediate color\r\n\t * between `minColor` and `maxColor` based on their `value` position between\r\n\t * `min` and `max`.\r\n\t *\r\n\t * @param {Color}  value  Highest color\r\n\t */\r\n\tpublic set maxColor(value: Color) {\r\n\t\tthis.setPropertyValue(\"maxColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Color} Highest color\r\n\t */\r\n\tpublic get maxColor(): Color {\r\n\t\treturn this.getPropertyValue(\"maxColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * User-defined highest value in the series.\r\n\t *\r\n\t * If not set, the map will use the highest `value` out of actual items in\r\n\t * the series.\r\n\t *\r\n\t * This is used to determine object's color in a heat map.\r\n\t *\r\n\t * @param {number}  value  Highest value\r\n\t */\r\n\tpublic set maxValue(value: number) {\r\n\t\tthis._maxValue = value;\r\n\t\tthis.invalidateData();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @return {number} Highest value\r\n\t */\r\n\tpublic get maxValue(): number {\r\n\t\tlet max = this._maxValue;\r\n\t\tif ($type.isNumber(max)) {\r\n\t\t\treturn max;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dataItem = this.dataItem;\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.values.value.high;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * User-defined lowest value in the series.\r\n\t *\r\n\t * If not set, the map will use the lowest `value` out of actual items in\r\n\t * the series.\r\n\t *\r\n\t * This is used to determine object's color in a heat map.\r\n\t *\r\n\t * @param {number}  value  Lowest value\r\n\t */\r\n\tpublic set minValue(value: number) {\r\n\t\tthis._minValue = value;\r\n\t\tthis.invalidateData();\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} Lowest value\r\n\t */\r\n\tpublic get minValue(): number {\r\n\t\tlet min = this._minValue;\r\n\r\n\t\tif ($type.isNumber(min)) {\r\n\t\t\treturn min;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dataItem = this.dataItem;\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.values.value.low;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A list of object ids that should be explictly included in the series.\r\n\t *\r\n\t * If this is not set, the series will automatically include all of the\r\n\t * objects, available in the GeoJSON map. (minus the ones listed in\r\n\t * `exclude`)\r\n\t *\r\n\t * If you need to display only specific objects, use `include`. E.g.:\r\n\t *\r\n\t * `include = [\"FR\", \"ES\", \"DE\"];`\r\n\t *\r\n\t * The above will show only France, Spain, and Germany out of the whole map.\r\n\t *\r\n\t * @param {string[]}  value  Included objects\r\n\t */\r\n\tpublic set include(value: string[]) {\r\n\t\tif (this.setPropertyValue(\"include\", value)) {\r\n\t\t\tthis.processIncExc();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected processIncExc() {\r\n\t\t//this.data = [];\r\n\t\tthis.invalidateData();\r\n\t}\r\n\r\n\t/**\r\n\t * @return {string[]} Included objects\r\n\t */\r\n\tpublic get include(): string[] {\r\n\t\treturn this.getPropertyValue(\"include\");\r\n\t}\r\n\r\n\t/**\r\n\t * A list of object ids that should be excluded from the series.\r\n\t *\r\n\t * E.g. you want to include all of the areas from a GeoJSON map, except\r\n\t * Antarctica.\r\n\t *\r\n\t * You'd leave `include` empty, and set `exclude = [\"AQ\"]`.\r\n\t *\r\n\t * @param {string[]}  value  Excluded ids\r\n\t */\r\n\tpublic set exclude(value: string[]) {\r\n\t\tif (this.setPropertyValue(\"exclude\", value)) {\r\n\t\t\tthis.processIncExc();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return {string[]} Excluded ids\r\n\t */\r\n\tpublic get exclude(): string[] {\r\n\t\treturn this.getPropertyValue(\"exclude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Decorates a newly added object.\r\n\t *\r\n\t * @param {IListEvents<MapObject>[\"insert\"]} event [description]\r\n\t */\r\n\tprotected handleObjectAdded(event: IListEvents<MapObject>[\"insert\"]) {\r\n\t\tlet mapObject: MapObject = event.newValue;\r\n\t\tmapObject.parent = this;\r\n\t\tmapObject.series = this;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapSeries\"] = MapSeries;\r\nsystem.registeredClasses[\"MapSeriesDataItem\"] = MapSeriesDataItem;\r\n\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSeries.ts","/**\r\n * Map object module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../../core/Container\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapSeries, MapSeriesDataItem } from \"./MapSeries\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { system } from \"../../core/System\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines propeties for [[MapObject]].\r\n */\r\nexport interface IMapObjectProperties extends IContainerProperties { }\r\n\r\n/**\r\n * Defines events for [[MapObject]].\r\n */\r\nexport interface IMapObjectEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapObject]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapObjectAdapters extends IContainerAdapters, IMapObjectProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A base class for all map objects: lines, images, etc.\r\n * \r\n * @see {@link IMapObjectEvents} for a list of available events\r\n * @see {@link IMapObjectAdapters} for a list of available Adapters\r\n */\r\nexport class MapObject extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapObjectProperties}\r\n\t */\r\n\tpublic _properties: IMapObjectProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapObjectAdapters}\r\n\t */\r\n\tpublic _adapter: IMapObjectAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapObject, IMapObjectEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapObject, IMapObjectEvents>>;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapSeries}\r\n\t */\r\n\tpublic series: MapSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapObject\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.layout = \"none\";\r\n\t\tthis.clickable = true;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates this object, forcing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tthis.readerTitle = this.series.itemReaderText;\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapObject\"] = MapObject;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapObject.ts","/**\r\n * A collection of GeoJSON format-related utility functions.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport * as $math from \"../../core/utils/Math\";\r\n\r\n\r\n/**\r\n * Normalizes a geo-point.\r\n *\r\n * @ignore Exclude from docs\r\n * @param  {IGeoPoint}  geoPoint  Source geo-point\r\n * @return {IGeoPoint}            Normalized geo-point\r\n */\r\nexport function normalizePoint(geoPoint: IGeoPoint): IGeoPoint {\r\n\tlet longitude = wrapAngleTo180(geoPoint.longitude);\r\n\tlet latitude = Math.asin(Math.sin((geoPoint.latitude * $math.RADIANS))) * $math.DEGREES;\r\n\r\n\tlet latitude180 = wrapAngleTo180(geoPoint.latitude);\r\n\r\n\tif (Math.abs(latitude180) > 90) {\r\n\t\tlongitude = wrapAngleTo180(longitude + 180);\r\n\t}\r\n\r\n\tgeoPoint.longitude = longitude;\r\n\tgeoPoint.latitude = latitude;\r\n\r\n\treturn geoPoint;\r\n}\r\n\r\n/**\r\n * Normalizes all points of a geo-line.\r\n *\r\n * @ignore Exclude from docs\r\n * @param  {IGeoPoint[][]}  multiline  Source geo-line\r\n * @return {IGeoPoint[]}               Normalized geo-line\r\n */\r\nexport function normalizeMultiline(multiline: IGeoPoint[][]): IGeoPoint[][] {\r\n\tfor (let segment of multiline) {\r\n\t\tfor (let point of segment) {\r\n\t\t\tpoint = normalizePoint(point);\r\n\t\t}\r\n\t}\r\n\treturn multiline;\r\n}\r\n\r\n/**\r\n * [wrapAngleTo180 description]\r\n *\r\n * @todo Description\r\n * @ignore Exclude from docs\r\n * @param  {number}  angle  Angle\r\n * @return {number}         Angle\r\n */\r\nexport function wrapAngleTo180(angle: number): number {\r\n\tangle = angle % 360;\r\n\r\n\tif (angle > 180) {\r\n\t\tangle -= 360;\r\n\t}\r\n\tif (angle < -180) {\r\n\t\tangle += 360;\r\n\t}\r\n\r\n\treturn angle;\r\n}\r\n\r\n/**\r\n * Converts a geo point to a regular point object.\r\n *\r\n * @ignore Exclude from docs\r\n * @param  {IGeoPoint}  geoPoint  Source geo point\r\n * @return {IPoint}               Point\r\n */\r\nexport function geoToPoint(geoPoint: IGeoPoint): IPoint {\r\n\treturn { x: geoPoint.longitude, y: geoPoint.latitude };\r\n}\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/Geo.ts","/**\r\n * Map line module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapLineObject } from \"./MapLineObject\";\r\nimport { MapLineSeriesDataItem, MapLineSeries } from \"./MapLineSeries\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapSeries } from \"./MapSeries\";\r\nimport { MapImage } from \"./MapImage\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { IRectangle } from \"../../core/defs/IRectangle\";\r\nimport { Triangle } from \"../../core/elements/Triangle\";\r\nimport { Circle } from \"../../core/elements/Circle\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { Polyline } from \"../../core/elements/Polyline\";\r\nimport { Polyspline } from \"../../core/elements/Polyspline\";\r\nimport { Polyarc } from \"../../core/elements/Polyarc\";\r\nimport { system } from \"../../core/System\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $geo from \"./Geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapLine]].\r\n */\r\nexport interface IMapLineProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Lat/long coordinates of all line ends and intermediate elbows.\r\n\t */\r\n\tmultiGeoLine?: IGeoPoint[][];\r\n\r\n\t/**\r\n\t * If `true` it line will be arched in the way to simulate shortest path \r\n\t * over curvature of Earth's surface, based on currently used on projection.\r\n\t * \r\n\t * @type {boolean}\r\n\t */\r\n\tshortestDistance?: boolean;\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images which will be connected by the line\r\n\t */\r\n\timagesToConnect?: MapImage[];\r\n}\r\n\r\n/**\r\n * Defines events for [[MapLine]].\r\n */\r\nexport interface IMapLineEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapLine]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapLineAdapters extends IMapObjectAdapters, IMapLineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a line on the map.\r\n * \r\n * @see {@link IMapLineEvents} for a list of available events\r\n * @see {@link IMapLineAdapters} for a list of available Adapters\r\n */\r\nexport class MapLine extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineProperties}\r\n\t */\r\n\tpublic _properties: IMapLineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineAdapters}\r\n\t */\r\n\tpublic _adapter: IMapLineAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapLine, IMapLineEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapLine, IMapLineEvents>>;\r\n\r\n\t/**\r\n\t * A line visual element.\r\n\t * \r\n\t * @type {Polyline}\r\n\t */\r\n\tpublic line: Polyline;\r\n\r\n\t/**\r\n\t * [_lineObjects description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {ListTemplate<MapLineObject>}\r\n\t */\r\n\tprotected _lineObjects: ListTemplate<MapLineObject>;\r\n\r\n\t/**\r\n\t * [_arrow description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {MapLineObject}\r\n\t */\r\n\tprotected _arrow: MapLineObject;\r\n\r\n\t/**\r\n\t * [_distance description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number}\r\n\t */\r\n\tprotected _distance: number;\r\n\r\n\t/**\r\n\t * Related data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapLineSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapLineSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapLineSeries}\r\n\t */\r\n\tpublic series: MapLineSeries;\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images which will be connected by the line\r\n\t * @ignore\r\n\t */\r\n\tprotected _imagesToConnect: MapImage[];\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapLine\";\r\n\r\n\t\t// Create a line and set its default properties\r\n\t\tthis.line = new Polyline();\r\n\t\tthis.line.stroke = color();\r\n\t\tthis.strokeOpacity = 1;\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tthis.stroke = interfaceColors.getFor(\"grid\");\r\n\t\tthis.shortestDistance = true;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a position within the line (0-1) to a physical point\r\n\t * coordinates.\r\n\t *\r\n\t * 0 indicates start of the line, 0.5 - middle, while 1 indicates the end.\r\n\t * \r\n\t * @param  {number}             position  Position (0-1)\r\n\t * @return {IOrientationPoint}            Coordinates\r\n\t */\r\n\tpublic positionToPoint(position: number): IOrientationPoint {\r\n\t\tif (this.line) {\r\n\t\t\treturn this.line.positionToPoint(position);\r\n\t\t}\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * [multiGeoLine description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param {IGeoPoint[][]} multiGeoLine [description]\r\n\t */\r\n\tpublic set multiGeoLine(multiGeoLine: IGeoPoint[][]) {\r\n\t\tthis.setPropertyValue(\"multiGeoLine\", $geo.normalizeMultiline(multiGeoLine), true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} [description]\r\n\t */\r\n\tpublic get multiGeoLine(): IGeoPoint[][] {\r\n\t\treturn this.getPropertyValue(\"multiGeoLine\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images which will be connected by the line\r\n\t *\r\n\t * @param {MapImages[]} images\r\n\t */\r\n\tpublic set imagesToConnect(images: MapImage[]) {\r\n\t\t//@todo dispose listeners if previous imagesToConnect exists\r\n\t\tfor (let image of images) {\r\n\t\t\timage.events.on(\"propertychanged\", (event) => { \r\n\t\t\t\tif(event.property == \"longitude\" || event.property == \"latitude\"){\r\n\t\t\t\t\tthis.invalidate();\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t\tthis.setPropertyValue(\"imagesToConnect\", images);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {MapImages[]}\r\n\t */\r\n\tpublic get imagesToConnect(): MapImage[] {\r\n\t\treturn this.getPropertyValue(\"imagesToConnect\");\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the line, effectively forcing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tlet chart: MapChart = this.series.chart;\r\n\t\tlet multiPoints: IPoint[][] = [];\r\n\t\tlet multiGeoLine: IGeoPoint[][] = this.multiGeoLine;\r\n\r\n\t\tif (this.imagesToConnect) {\r\n\t\t\tlet segment: IGeoPoint[] = [];\r\n\t\t\tmultiGeoLine = [segment];\r\n\r\n\t\t\tfor (let image of this.imagesToConnect) {\r\n\t\t\t\tsegment.push({ longitude: image.longitude, latitude: image.latitude });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.shortestDistance) {\r\n\t\t\tlet newMultiGeoLine: IGeoPoint[][] = [];\r\n\r\n\t\t\tfor (let i = 0; i < multiGeoLine.length; i++) {\r\n\t\t\t\tlet geoLine: IGeoPoint[] = multiGeoLine[i];\r\n\t\t\t\tlet newGeoLine: IGeoPoint[] = [];\r\n\r\n\t\t\t\tfor (let p = 1; p < geoLine.length; p++) {\r\n\t\t\t\t\tlet geoPointA: IGeoPoint = geoLine[p - 1];\r\n\t\t\t\t\tlet geoPointB: IGeoPoint = geoLine[p];\r\n\r\n\t\t\t\t\tlet stepCount: number = Math.max(Math.abs(geoPointA.latitude - geoPointB.latitude), Math.abs(geoPointA.longitude - geoPointB.longitude));\r\n\t\t\t\t\tlet latitudeStep: number = (geoPointB.latitude - geoPointA.latitude) / stepCount;\r\n\t\t\t\t\tlet longitudeStep: number = (geoPointB.longitude - geoPointA.longitude) / stepCount;\r\n\r\n\t\t\t\t\tfor (let d = 0; d < stepCount; d++) {\r\n\t\t\t\t\t\tlet intermediatePoint = chart.projection.intermediatePoint(geoPointA, geoPointB, d / stepCount);\r\n\r\n\t\t\t\t\t\tif (newGeoLine.length > 0) {\r\n\t\t\t\t\t\t\tlet previousPoint = newGeoLine[newGeoLine.length - 1];\r\n\t\t\t\t\t\t\tif (Math.abs(previousPoint.longitude - intermediatePoint.longitude) > 359) {\r\n\t\t\t\t\t\t\t\tnewMultiGeoLine.push(newGeoLine);\r\n\t\t\t\t\t\t\t\tnewGeoLine = [];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnewGeoLine.push(intermediatePoint);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tnewMultiGeoLine.push(newGeoLine);\r\n\t\t\t}\r\n\t\t\tmultiGeoLine = newMultiGeoLine;\r\n\t\t}\r\n\r\n\t\tthis.line.segments = chart.projection.projectGeoLine(multiGeoLine);\r\n\r\n\t\tif (this._arrow) {\r\n\t\t\tthis._arrow.validatePosition();\r\n\t\t}\r\n\r\n\t\t$iter.each(this.lineObjects.iterator(), (x) => {\r\n\t\t\tx.validatePosition();\r\n\t\t});\r\n\r\n\t\tthis.line.parent = this;\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\t// Overriding, just to avoid extra measure\r\n\t}\r\n\r\n\t/**\r\n\t * The line should take the shortest path over the globe\r\n\t *\r\n\t * Enabling this will make the line look differently in different\r\n\t * projections. Only MapLine supports this setting, MapArc and MapSplice doesn't\r\n\t *\r\n\t * @default false\r\n\t * @param {boolean}  value  Real path?\r\n\t */\r\n\tpublic set shortestDistance(value: boolean) {\r\n\t\tthis.setPropertyValue(\"shortestDistance\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {boolean} Real path?\r\n\t */\r\n\tpublic get shortestDistance(): boolean {\r\n\t\treturn this.getPropertyValue(\"shortestDistance\");\r\n\t}\r\n\r\n\t/**\r\n\t * List of separate line objects, the line consists of.\r\n\t *\r\n\t * @todo Description (review)\r\n\t * @readonly\r\n\t * @return {ListTemplate<MapLineObject>} List of line objects\r\n\t */\r\n\tpublic get lineObjects(): ListTemplate<MapLineObject> {\r\n\t\tif (!this._lineObjects) {\r\n\t\t\tthis._lineObjects = new ListTemplate<MapLineObject>(new MapLineObject());\r\n\t\t\tthis._lineObjects.events.on(\"insert\", this.handleLineObjectAdded, this);\r\n\t\t}\r\n\r\n\t\treturn this._lineObjects;\r\n\t}\r\n\r\n\t/**\r\n\t * Decorate a [[LineObject]] when it is added to the line.\r\n\t * \r\n\t * @param {IListEvents<MapLineObject>[\"insert\"]}  event  Event\r\n\t */\r\n\tprotected handleLineObjectAdded(event: IListEvents<MapLineObject>[\"insert\"]) {\r\n\t\tlet mapLineObject: MapLineObject = event.newValue;\r\n\t\tmapLineObject.mapLine = this;\r\n\t\tmapLineObject.parent = this;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapLineObject]] to use as an option arrowhead on the line.\r\n\t *\r\n\t * Just accessing this property will create a default arrowhead on the line\r\n\t * automatically.\r\n\t * \r\n\t * @param {MapLineObject}  arrow  Arrow element\r\n\t */\r\n\tpublic set arrow(arrow: MapLineObject) {\r\n\t\tthis._arrow = arrow;\r\n\t\tarrow.mapLine = this;\r\n\t\tarrow.parent = this;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {MapLineObject} Arrow element\r\n\t */\r\n\tpublic get arrow(): MapLineObject {\r\n\t\tif (!this._arrow) {\r\n\t\t\tlet arrow: MapLineObject = this.createChild(MapLineObject);\r\n\t\t\tarrow.width = 8;\r\n\t\t\tarrow.height = 10;\r\n\t\t\tarrow.mapLine = this;\r\n\t\t\tarrow.position = 0.5;\r\n\r\n\t\t\tlet triangle = arrow.createChild(Triangle);\r\n\t\t\ttriangle.fillOpacity = 1;\r\n\t\t\ttriangle.width = percent(100);\r\n\t\t\ttriangle.height = percent(100);\r\n\t\t\ttriangle.rotation = 90;\r\n\t\t\ttriangle.horizontalCenter = \"middle\";\r\n\t\t\ttriangle.verticalCenter = \"middle\";\r\n\t\t\tthis._arrow = arrow;\r\n\t\t}\r\n\t\treturn this._arrow;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies line properties and other attributes, like arrow, from another\r\n\t * instance of [[MapLine]].\r\n\t * \r\n\t * @param {MapLineObject}  source  Source map line\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.lineObjects.copyFrom(source.lineObjects);\r\n\t\tif (source._arrow) {\r\n\t\t\tthis.arrow = <MapLineObject>source.arrow.clone();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the line center.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\tlet dataItem = this.dataItem;\r\n\t\treturn dataItem.north + (dataItem.south - dataItem.north) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the line center.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Latitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\tlet dataItem = this.dataItem;\r\n\t\treturn dataItem.east + (dataItem.west - dataItem.east) / 2;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapLine\"] = MapLine;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLine.ts","/**\r\n * A collection of Map-related utility functions.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\n\r\n/**\r\n * Converts a multi-part polygon in X/Y coordinates to a geo-multipolygon in\r\n * geo-points (lat/long).\r\n * \r\n * @param  {number[][][][]}  multiPolygon  Source multi-polygon\r\n * @return {IGeoPoint[]}                   Geo-multipolygon\r\n */\r\n\r\nexport function multiPolygonToGeo(multiPolygon: number[][][][]): IGeoPoint[][][] {\r\n\tlet multiGeoArea: IGeoPoint[][][] = [];\r\n\r\n\tfor (let i: number = 0; i < multiPolygon.length; i++) {\r\n\r\n\t\tlet surface: number[][] = multiPolygon[i][0];\r\n\t\tlet hole: number[][] = multiPolygon[i][1];\r\n\r\n\t\tlet holePoints: IGeoPoint[] = [];\r\n\r\n\t\tmultiGeoArea[i] = [];\r\n\r\n\t\tif (surface) {\r\n\t\t\tmultiGeoArea[i].push(multiPointToGeo(surface));\r\n\t\t}\r\n\r\n\t\tif (hole) {\r\n\t\t\tmultiGeoArea[i].push(multiPointToGeo(hole));\r\n\t\t}\r\n\t}\r\n\treturn multiGeoArea;\r\n}\r\n\r\n/**\r\n * Converts a multiline in X/Y coordinates to a geo-multiline in geo-points\r\n * (lat/long).\r\n * \r\n * @param  {number[][][]}  multiLine  Source multiline\r\n * @return {IGeoPoint[]}              Geo-multiline\r\n */\r\nexport function multiLineToGeo(multiLine: number[][][]): IGeoPoint[][] {\r\n\tlet multiGeoLine: IGeoPoint[][] = [];\r\n\r\n\tfor (let i = 0; i < multiLine.length; i++) {\r\n\t\tmultiGeoLine.push(multiPointToGeo(multiLine[i]));\r\n\t}\r\n\treturn multiGeoLine;\r\n}\r\n\r\n/**\r\n * Converts multiple X/Y points into a lat/long geo-points.\r\n * \r\n * @param  {number[][]}   points  Source points\r\n * @return {IGeoPoint[]}          Geo-points\r\n */\r\nexport function multiPointToGeo(points: number[][]): IGeoPoint[] {\r\n\tlet geoPoints: IGeoPoint[] = [];\r\n\tfor (let i = 0; i < points.length; i++) {\r\n\t\tgeoPoints.push(pointToGeo(points[i]));\r\n\t}\r\n\treturn geoPoints;\r\n}\r\n\r\n/**\r\n * Converts X/Y point into a lat/long geo-point.\r\n * \r\n * @param  {number[]}   point  Source point\r\n * @return {IGeoPoint}         Geo-point\r\n */\r\nexport function pointToGeo(point: number[]): IGeoPoint {\r\n\treturn { longitude: point[0], latitude: point[1] }\r\n}\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapUtils.ts","/**\r\n *\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { MapImageSeriesDataItem, MapImageSeries } from \"./MapImageSeries\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $type from \"../../core/utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapImage]].\r\n */\r\nexport interface IMapImageProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Latitude of the image location.\r\n\t * \r\n\t * @type {number}\r\n\t */\r\n\tlatitude?: number;\r\n\r\n\t/**\r\n\t * Longitude of the mage location.\r\n\t * \r\n\t * @type {number}\r\n\t */\r\n\tlongitude?: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[MapImage]].\r\n */\r\nexport interface IMapImageEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapImage]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapImageAdapters extends IMapObjectAdapters, IMapImageProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to place an image on the map.\r\n * \r\n * @see {@link IMapImageEvents} for a list of available events\r\n * @see {@link IMapImageAdapters} for a list of available Adapters\r\n */\r\nexport class MapImage extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapImageProperties}\r\n\t */\r\n\tpublic _properties: IMapImageProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapImageAdapters}\r\n\t */\r\n\tpublic _adapter: IMapImageAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapImage, IMapImageEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapImage, IMapImageEvents>>;\r\n\r\n\t/**\r\n\t * A related data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapImageSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapImageSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapImageSeries}\r\n\t */\r\n\tpublic series: MapImageSeries;\t\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"MapImage\";\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude image is placed at.\r\n\t * \r\n\t * @param {number}  value  Latitude\r\n\t */\r\n\tpublic set latitude(value: number) {\r\n\t\tthis.setPropertyValue(\"latitude\", value, false, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} Latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\treturn this.getPropertyValue(\"latitude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude image is placed on.\r\n\t * \r\n\t * @param {number}  value  Longitude\r\n\t */\r\n\tpublic set longitude(value: number) {\r\n\t\tthis.setPropertyValue(\"longitude\", value, false, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} Longitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\treturn this.getPropertyValue(\"longitude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Repositions the image to it's current position.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validatePosition(): void {\r\n\t\tif ($type.isNumber(this.latitude) && $type.isNumber(this.longitude)) {\r\n\t\t\tthis.moveTo(this.series.chart.projection.convert({ latitude: this.latitude, longitude: this.longitude }));\r\n\t\t}\r\n\t\tsuper.validatePosition();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapImage\"] = MapImage;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapImage.ts","/**\r\n * Map polygon module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapPolygonSeriesDataItem, MapPolygonSeries } from \"./MapPolygonSeries\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapSeries } from \"./MapSeries\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Polygon } from \"../../core/elements/Polygon\";\r\nimport { IRectangle } from \"../../core/defs/IRectangle\";\r\nimport { Circle } from \"../../core/elements/Circle\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\n\r\n\r\n/**\r\n * ============================f================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Set of coordinates for the polygon.\r\n\t */\r\n\tmultiGeoPolygon?: IGeoPoint[][][];\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapPolygon]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapPolygonAdapters extends IMapObjectAdapters, IMapPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a polygon on the map.\r\n * \r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class MapPolygon extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapPolygonProperties}\r\n\t */\r\n\tpublic _properties: IMapPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapPolygonAdapters}\r\n\t */\r\n\tpublic _adapter: IMapPolygonAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapPolygon, IMapPolygonEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapPolygon, IMapPolygonEvents>>;\r\n\r\n\t/**\r\n\t * A visual polygon element.\r\n\t * \r\n\t * @type {Polygon}\r\n\t */\r\n\tpublic polygon: Polygon;\r\n\r\n\t/**\r\n\t * A related data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapPolygonSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapPolygonSeriesDataItem;\r\n\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapPolygonSeries}\r\n\t */\r\n\tpublic series: MapPolygonSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"MapPolygon\";\r\n\r\n\t\tthis.polygon = this.createChild(Polygon);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tthis.fill = interfaceColors.getFor(\"secondaryButton\");\r\n\t\tthis.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\r\n\t\tthis.strokeOpacity = 1;\r\n\r\n\t\t/*this.events.on(\"focus\", (event) => {\r\n\t\t\t//this.toFront();\r\n\t\t\t//this.isFocused = true;\r\n\t\t});*/\r\n\r\n\t\tthis.tooltipPosition = \"mouse\";\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Set of coordinates for the polygon.\r\n\t * \r\n\t * @param {IGeoPoint[][][]}  multiGeoPolygon  Polygon coordinates\r\n\t */\r\n\tpublic set multiGeoPolygon(multiGeoPolygon: IGeoPoint[][][]) {\r\n\t\tthis.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} Polygon coordinates\r\n\t */\r\n\tpublic get multiGeoPolygon(): IGeoPoint[][][] {\r\n\t\treturn this.getPropertyValue(\"multiGeoPolygon\");\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the polygon, effectively redrawing it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tif (this.series) {\r\n\t\t\tthis.polygon.points = this.series.chart.projection.projectGeoArea(this.multiGeoPolygon);\r\n\t\t\tthis.series.fillRule(this);\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\t// Overriding, just to avoid extra measure\r\n\t}\r\n\r\n\t/**\r\n\t * Calculated polygon center latitude.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Center latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\tlet dataItem = this.dataItem;\r\n\t\treturn dataItem.north + (dataItem.south - dataItem.north) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculated polygon center longitude.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Center longitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\tlet dataItem = this.dataItem;\r\n\t\treturn dataItem.east + (dataItem.west - dataItem.east) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Not 100% sure about this, as if we add something to MapPolygon this \r\n\t * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n\t * be positioned properly\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Element's width in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Width (px)\r\n\t */\r\n\tpublic get pixelWidth(): number {\r\n\t\treturn this.polygon.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's height in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Width (px)\r\n\t */\r\n\tpublic get pixelHeight(): number {\r\n\t\treturn this.polygon.pixelHeight;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's horizontal overflow in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Overflow (px)\r\n\t */\r\n\tpublic get overflowX(): number {\r\n\t\treturn this.polygon.overflowX;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's vertical overflow in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Overflow (px)\r\n\t */\r\n\tpublic get overflowY(): number {\r\n\t\treturn this.polygon.overflowY;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapPolygon\"] = MapPolygon;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapPolygon.ts","/**\r\n * Map line series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapSeries, MapSeriesDataItem, GEOJSONGeometry, IMapSeriesProperties, IMapSeriesDataFields, IMapSeriesAdapters, IMapSeriesEvents } from \"./MapSeries\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart, MapLineType } from \"../types/MapChart\";\r\nimport { MapLine } from \"./MapLine\";\r\nimport { MapArc } from \"./MapArc\";\r\nimport { MapSpline } from \"./MapSpline\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { IMapDataObject, IMapPolygonDataObject, IMapLineDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapLineSeries]]\r\n * @see {@link DataItem}\r\n */\r\nexport class MapLineSeriesDataItem extends MapSeriesDataItem {\r\n\r\n\t/**\r\n\t * A [[MapLine]] element related to this data item.\r\n\t * \r\n\t * @type {MapLine}\r\n\t */\r\n\tprotected _mapLine: MapLine;\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a single-segment line.\r\n\t *\r\n\t * @type {number[][]}\r\n\t */\r\n\tprotected _line: number[][];\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-segment line.\r\n\t *\r\n\t * @type {number[][][]}\r\n\t */\r\n\tprotected _multiLine: number[][][];\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a single-segment line.\r\n\t *\r\n\t * @type {IGeoPoint[]}\r\n\t */\r\n\tprotected _geoLine: IGeoPoint[];\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a multi-segment line.\r\n\t *\r\n\t * @type {IGeoPoint[][]}\r\n\t */\r\n\tprotected _multiGeoLine: IGeoPoint[][];\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for\r\n\t * @type {MapLineSeries}\r\n\t */\r\n\tpublic _component: MapLineSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapLineSeriesDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapLine]] element related to this data item.\r\n\t *\r\n\t * @readonly\r\n\t * @return {MapLine} Element\r\n\t */\r\n\tpublic get mapLine(): MapLine {\r\n\t\tif (!this._mapLine) {\r\n\t\t\tthis._mapLine = this.component.mapLines.create(MapLine);\r\n\t\t\tthis.addSprite(this._mapLine);\r\n\t\t}\r\n\t\treturn this._mapLine;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a single-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   [ 100, 150 ],\r\n\t *   [ 120, 200 ]\r\n\t * ]\r\n\t * ```\r\n\t * \r\n\t * @param {number[][]}  line  Coordinates\r\n\t */\r\n\tpublic set line(line: number[][]) {\r\n\t\tthis._line = line;\r\n\t\tthis.multiGeoLine = $mapUtils.multiLineToGeo([line]);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number[]} Coordinates\r\n\t */\r\n\tpublic get line(): number[][] {\r\n\t\treturn this._line;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Segment 1\r\n\t *   [\r\n\t *     [ 100, 150 ],\r\n\t *     [ 120, 200 ]\r\n\t *   ],\r\n\t *\r\n\t *   // Segment 2\r\n\t *   [\r\n\t *     [ 120, 200 ],\r\n\t *     [ 150, 100 ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t * \r\n\t * @param {number[][]}  multiLine  Coordinates\r\n\t */\r\n\tpublic set multiLine(multiLine: number[][][]) {\r\n\t\tthis._multiLine = multiLine;\r\n\t\tthis.multiGeoLine = $mapUtils.multiLineToGeo(multiLine);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number[]} Coordinates\r\n\t */\r\n\tpublic get multiLine(): number[][][] {\r\n\t\treturn this._multiLine;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a single-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { longitude: 3.121, latitude: 0.58 },\r\n\t *   { longitude: -5.199, latitude: 21.223 }\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.4} GeoJSON LineString reference\r\n\t * @param {IGeoPoint[][]}  geoLine  Coordinates\r\n\t */\r\n\tpublic set geoLine(geoLine: IGeoPoint[]) {\r\n\t\tthis._geoLine = geoLine;\r\n\t\tthis.multiGeoLine = [geoLine];\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} Coordinates\r\n\t */\r\n\tpublic get geoLine(): IGeoPoint[] {\r\n\t\treturn this._geoLine;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Segment 1\r\n\t *   [\r\n\t *     { longitude: 3.121, latitude: 0.58 },\r\n\t *     { longitude: -5.199, latitude: 21.223 }\r\n\t *   ],\r\n\t *\r\n\t *   // Segment 2\r\n\t *   [\r\n\t *     { longitude: -5.199, latitude: 21.223 },\r\n\t *     { longitude: -12.9, latitude: 25.85 }\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.5} GeoJSON MultiLineString reference\r\n\t * @param {IGeoPoint[][]}  multiGeoLine  Coordinates\r\n\t */\r\n\tpublic set multiGeoLine(multiGeoLine: IGeoPoint[][]) {\r\n\t\tthis._multiGeoLine = multiGeoLine;\r\n\t\tthis.updateLineExtremes(multiGeoLine);\r\n\t\tthis.mapLine.multiGeoLine = this._multiGeoLine;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} Coordinates\r\n\t */\r\n\tpublic get multiGeoLine(): IGeoPoint[][] {\r\n\t\treturn this._multiGeoLine;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the item's bounding coordinates: coordinates of the East, West,\r\n\t * North, and South-most points.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {IGeoPoint[]}  geoPoints  Points of the element\r\n\t */\r\n\tpublic updateLineExtremes(multiGeoLine: IGeoPoint[][]): void {\r\n\t\tfor (let i = 0; i < multiGeoLine.length; i++) {\r\n\t\t\tlet geoLine: IGeoPoint[] = multiGeoLine[i];\r\n\t\t\tthis.updateExtremes(geoLine);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[MapLineSeries]].\r\n */\r\nexport interface IMapLineSeriesDataFields extends IMapSeriesDataFields {\r\n\r\n\t/**\r\n\t * Field name that holds line data in pixels.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tline?: string;\r\n\r\n\t/**\r\n\t * Field name that holds multi-line data in pixels.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiLine?: string;\r\n\r\n\t/**\r\n\t * Field name that holds line data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tgeoLine?: string;\r\n\r\n\t/**\r\n\t * Field name that holds multi-line data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiGeoLine?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[MapLineSeries]].\r\n */\r\nexport interface IMapLineSeriesProperties extends IMapSeriesProperties { }\r\n\r\n/**\r\n * Defines events for [[MapLineSeries]].\r\n */\r\nexport interface IMapLineSeriesEvents extends IMapSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapLineSeries]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapLineSeriesAdapters extends IMapSeriesAdapters, IMapLineSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A series of map line series.\r\n * \r\n * @see {@link IMapLineSeriesEvents} for a list of available Events\r\n * @see {@link IMapLineSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapLineSeries extends MapSeries {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapLineSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapLineSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapLineSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapLineSeries, IMapLineSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapLineSeries, IMapLineSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapLineSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapLineSeriesDataItem;\r\n\r\n\r\n\t/**\r\n\t * A related chart/map object, this element is drawn on.\r\n\t * \r\n\t * @type {MapChart}\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\t/**\r\n\t * Defines the type of the line items in this series.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapLine}\r\n\t */\r\n\tpublic _mapLine: MapLine;\r\n\r\n\t/**\r\n\t * A list of map lins in the series.\r\n\t * \r\n\t * @type {ListTemplate<MapImage>}\r\n\t */\r\n\tprotected _mapLines: ListTemplate<this[\"_mapLine\"]>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapLineSeries\";\r\n\r\n\t\t// Set data fields\r\n\t\tthis.dataFields.multiLine = \"multiLine\";\r\n\t\tthis.dataFields.line = \"line\";\r\n\r\n\t\tthis.dataFields.geoLine = \"geoLine\";\r\n\t\tthis.dataFields.multiGeoLine = \"multiGeoLine\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t * \r\n\t * @see {@link DataItem}\r\n\t * @return {MapLineSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapLineSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates series data, effectively causing the whole series to be\r\n\t * redrawn.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tif (this.data.length > 0) {\r\n\t\t\tthis.mapLines.clear();\r\n\t\t}\r\n\r\n\t\t// process geoJSON and created map objects\r\n\t\tif (this.getDataFromJSON) {\r\n\t\t\tlet geoJSON: any = this.chart.geoJSON;\r\n\t\t\tif (geoJSON) {\r\n\r\n\t\t\t\tlet features: any[];\r\n\r\n\t\t\t\tif (geoJSON.type == \"FeatureCollection\") {\r\n\t\t\t\t\tfeatures = geoJSON.features;\r\n\t\t\t\t}\r\n\t\t\t\telse if (geoJSON.type == \"Feature\") {\r\n\t\t\t\t\tfeatures = [geoJSON];\r\n\t\t\t\t}\r\n\t\t\t\telse if ([\"Point\", \"LineString\", \"Polygon\", \"MultiPoint\", \"MultiLineString\", \"MultiPolygon\"].indexOf(geoJSON.type) != -1) {\r\n\t\t\t\t\tfeatures = [{ geometry: geoJSON }];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"nothing found in geoJSON\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (features) {\r\n\t\t\t\t\tfor (let i = 0; i < features.length; i++) {\r\n\r\n\t\t\t\t\t\tlet feature: any = features[i];\r\n\t\t\t\t\t\tlet geometry: any = feature.geometry;\r\n\t\t\t\t\t\tif (geometry) {\r\n\t\t\t\t\t\t\tlet type: GEOJSONGeometry = <GEOJSONGeometry>geometry.type;\r\n\t\t\t\t\t\t\tlet id: string = feature.id;\r\n\t\t\t\t\t\t\tif (type == \"LineString\" || type == \"MultiLineString\") {\r\n\r\n\t\t\t\t\t\t\t\tif (!this.checkInclude(this.include, this.exclude, id)) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet coordinates: any[] = geometry.coordinates;\r\n\r\n\t\t\t\t\t\t\t\tif (coordinates) {\r\n\t\t\t\t\t\t\t\t\t// make the same as MultiPolygon\r\n\t\t\t\t\t\t\t\t\tif (type == \"MultiLineString\") {\r\n\t\t\t\t\t\t\t\t\t\tcoordinates = [coordinates];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet dataObject: IMapLineDataObject = $array.find(this.data, (value, i) => {\r\n\t\t\t\t\t\t\t\t\treturn value.id == id;\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tif (!dataObject) {\r\n\t\t\t\t\t\t\t\t\tdataObject = { multiLineString: coordinates, id: id };\r\n\t\t\t\t\t\t\t\t\tthis.data.push(dataObject);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tif (!dataObject.multiLineString) {\r\n\t\t\t\t\t\t\t\t\t\tdataObject.multiLineString = coordinates;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// copy properties data to datacontext\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(feature.properties, dataObject);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if data is parsed in chunks, lines list is corrupted, fix it here\r\n\t\t$iter.each(this.dataItems.iterator(), (dataItem) => {\r\n\t\t\tthis.mapLines.moveValue(dataItem.mapLine);\r\n\t\t});\r\n\r\n\r\n\t\tsuper.validateData();\r\n\t}\r\n\r\n\t/**\r\n\t * A list of lines in the series.\r\n\t * \r\n\t * @return {ListTemplate} Lines\r\n\t */\r\n\tpublic get mapLines(): ListTemplate<this[\"_mapLine\"]> {\r\n\r\n\t\tif (!this._mapLines) {\r\n\t\t\tlet lineTemplate: MapLine = this.createLine();\r\n\t\t\tlet mapLines = new ListTemplate<MapLine>(lineTemplate);\r\n\t\t\tmapLines.events.on(\"insert\", this.handleObjectAdded, this);\r\n\t\t\tthis._mapLines = mapLines;\r\n\t\t}\r\n\r\n\t\treturn this._mapLines;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new line instance of suitable type.\r\n\t * \r\n\t * @return {MapLine} New line\r\n\t */\r\n\tprotected createLine(): this[\"_mapLine\"] {\r\n\t\treturn new MapLine();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the series\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tsuper.validate();\r\n\t\t$iter.each(this.mapLines.iterator(), (mapLine) => {\r\n\t\t\tmapLine.validate();\r\n\t\t})\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapLineSeries\"] = MapLineSeries;\r\nsystem.registeredClasses[\"MapLineSeriesDataItem\"] = MapLineSeriesDataItem;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLineSeries.ts","/**\r\n * A module for the mini-map control.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../../core/Container\";\r\nimport { Sprite, ISpriteEvents, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { Button } from \"../../core/elements/Button\";\r\nimport { Rectangle } from \"../../core/elements/Rectangle\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapSeries } from \"./MapSeries\";\r\nimport { MapPolygonSeries } from \"./MapPolygonSeries\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { MutableValueDisposer, MultiDisposer } from \"../../core/utils/Disposer\";\r\nimport { system } from \"../../core/System\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { ColorSet } from \"../../core/utils/ColorSet\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[SmallMap]].\r\n */\r\nexport interface ISmallMapProperties extends IContainerProperties { }\r\n\r\n/**\r\n * Defines events for [[SmallMap]].\r\n */\r\nexport interface ISmallMapEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[SmallMap]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface ISmallMapAdapters extends IContainerAdapters, ISmallMapProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a \"bird's eye\" view of the whole map.\r\n *\r\n * This control creates a mini-map with the whole of the map, highlighting\r\n * the area which is in the current viewport of the map map.\r\n * \r\n * @see {@link ISmallMapEvents} for a list of available events\r\n * @see {@link ISmallMapAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class SmallMap extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t * \r\n\t * @ignore Exclude from docs\r\n\t * @type {SmallMaPproperties}\r\n\t */\r\n\tpublic _properties: ISmallMapProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {ISmallMapAdapters}\r\n\t */\r\n\tpublic _adapter: ISmallMapAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<SmallMap, ISmallMapEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<SmallMap, ISmallMapEvents>>;\r\n\r\n\t/**\r\n\t * A target map.\r\n\t * \r\n\t * @type {MutableValueDisposer<MapChart>}\r\n\t */\r\n\tprotected _chart: MutableValueDisposer<MapChart> = new MutableValueDisposer<MapChart>();\r\n\r\n\t/**\r\n\t * A list of map series used to draw the mini-map.\r\n\t * \r\n\t * @type {ListTemplate<MapSeries>}\r\n\t */\r\n\tpublic series: ListTemplate<MapSeries>;\r\n\r\n\t/**\r\n\t * A container that holds the visual elements for the mini-map.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {Container}\r\n\t */\r\n\tpublic seriesContainer: Container;\r\n\r\n\t/**\r\n\t * The rectangle element which highlights current viewport.\r\n\t * \r\n\t * @type {Rectangle}\r\n\t */\r\n\tpublic rectangle: Rectangle;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"SmallMap\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.align = \"left\";\r\n\t\tthis.valign = \"bottom\";\r\n\t\tthis.percentHeight = 20;\r\n\t\tthis.percentWidth = 20;\r\n\t\tthis.margin(5, 5, 5, 5);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\t// Set background defailts\r\n\t\tthis.background.fillOpacity = 0.9;\r\n\t\tthis.background.fill = interfaceColors.getFor(\"background\");\r\n\r\n\t\t// Set up events\r\n\t\tthis.events.on(\"hit\", this.moveToPosition, this);\r\n\t\tthis.events.on(\"maxsizechanged\", this.updateMapSize, this);\r\n\r\n\t\t// Create series\r\n\t\tthis.series = new ListTemplate<MapSeries>(new MapSeries());\r\n\t\tthis.series.events.on(\"insert\", this.processSeries, this);\r\n\r\n\t\t// Create a container\r\n\t\tthis.seriesContainer = this.createChild(Container);\r\n\r\n\t\t// Create an outline rectangle\r\n\t\tlet rectangle: Rectangle = this.createChild(Rectangle);\r\n\t\trectangle.stroke = interfaceColors.getFor(\"alternativeBackground\");\r\n\t\trectangle.strokeWidth = 1;\r\n\t\trectangle.strokeOpacity = 0.5;\r\n\t\trectangle.fill = color(); //\"none\";\r\n\t\trectangle.verticalCenter = \"middle\";\r\n\t\trectangle.horizontalCenter = \"middle\";\r\n\t\trectangle.isMeasured = false;\r\n\t\tthis.rectangle = rectangle;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Moves main map pan position after click on the small map.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {AMEvent<Sprite, ISpriteEvents>[\"hit\"]}  event  Event\r\n\t */\r\n\tpublic moveToPosition(event: AMEvent<Sprite, ISpriteEvents>[\"hit\"]) {\r\n\t\tlet svgPoint: IPoint = event.svgPoint;\r\n\t\tlet rectPoint: IPoint = $utils.svgPointToSprite(svgPoint, this.rectangle);\r\n\r\n\t\tlet zoomLevel: number = this.chart.zoomLevel;\r\n\t\tlet scale: number = Math.min(this.percentWidth, this.percentHeight) / 100;\r\n\t\tlet x: number = (rectPoint.x + this.rectangle.pixelWidth / 2) / scale * zoomLevel;\r\n\t\tlet y: number = (rectPoint.y + this.rectangle.pixelHeight / 2) / scale * zoomLevel;\r\n\r\n\t\tlet geoPoint: IGeoPoint = this.chart.svgPointToGeo({ x: x, y: y });\r\n\r\n\t\tthis.chart.zoomToGeoPoint(geoPoint, this.chart.zoomLevel, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Decorates a new [[MapSeries]] object with required parameters when it is\r\n\t * added to the chart.\r\n\t * \r\n\t * @param {IListEvents<MapSeries>[\"insert\"]} event [description]\r\n\t */\r\n\tpublic processSeries(event: IListEvents<MapSeries>[\"insert\"]): void {\r\n\t\tlet series: MapSeries = event.newValue;\r\n\t\tseries.chart = this.chart;\r\n\t\tseries.parent = this.seriesContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * A chart/map that this control is meant for.\r\n\t * \r\n\t * @param {MapChart}  chart  Chart/map\r\n\t */\r\n\tpublic set chart(chart: MapChart) {\r\n\t\tif (this.chart != chart) {\r\n\t\t\tthis._chart.set(chart, new MultiDisposer([\r\n\t\t\t\tchart.events.on(\"zoomlevelchanged\", this.updateRectangle, this),\r\n\t\t\t\tchart.events.on(\"mappositionchanged\", this.updateRectangle, this),\r\n\t\t\t\tchart.events.on(\"scaleratiochanged\", this.updateMapSize, this)\r\n\t\t\t]));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return {MapChart} Chart/map\r\n\t */\r\n\tpublic get chart(): MapChart {\r\n\t\treturn this._chart.get();\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the viewport recangle as per current map zoom/pan position.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateRectangle(): void {\r\n\t\tlet chart: MapChart = this.chart;\r\n\t\tlet zoomLevel: number = chart.zoomLevel;\r\n\t\tlet rectangle: Rectangle = this.rectangle;\r\n\r\n\t\trectangle.width = this.pixelWidth / zoomLevel;\r\n\t\trectangle.height = this.pixelHeight / zoomLevel;\r\n\r\n\t\tlet scale: number = Math.min(this.percentWidth, this.percentHeight) / 100;\r\n\r\n\t\tlet seriesContainer: Container = chart.seriesContainer;\r\n\r\n\t\tlet x: number = Math.ceil((zoomLevel * seriesContainer.pixelWidth / 2 - seriesContainer.pixelX) * scale / zoomLevel + rectangle.pixelWidth / 2);\r\n\t\tlet y: number = Math.ceil((zoomLevel * seriesContainer.pixelHeight / 2 - seriesContainer.pixelY) * scale / zoomLevel + rectangle.pixelHeight / 2);\r\n\r\n\t\trectangle.x = x;\r\n\t\trectangle.y = y;\r\n\t}\r\n\r\n\t/**\r\n\t * Update map size so that internal elements can redraw themselves after\r\n\t * the size of the small map changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateMapSize(): void {\r\n\t\tif(this.chart){\r\n\t\t\tthis.seriesContainer.scale = this.chart.scaleRatio * Math.min(this.percentWidth, this.percentHeight) / 100;\r\n\t\t\tthis.afterDraw();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Update elements after drawing the small map.\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\tsuper.afterDraw();\r\n\t\tthis.seriesContainer.moveTo({ x: this.pixelWidth / 2, y: this.pixelHeight / 2 });\r\n\t\tthis.rectangle.maskRectangle = { x: -1, y: -1, width: Math.ceil(this.pixelWidth + 2), height: Math.ceil(this.pixelHeight + 2) };\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"SmallMap\"] = SmallMap;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/SmallMap.ts","/**\r\n * Map spline module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapLine, IMapLineProperties, IMapLineAdapters, IMapLineEvents } from \"./MapLine\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { Polyspline } from \"../../core/elements/Polyspline\";\r\nimport { MapSplineSeriesDataItem, MapSplineSeries } from \"./MapSplineSeries\";\r\nimport { system } from \"../../core/System\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapSpline]].\r\n */\r\nexport interface IMapSplineProperties extends IMapLineProperties { }\r\n\r\n/**\r\n * Defines events for [[MapSpline]].\r\n */\r\nexport interface IMapSplineEvents extends IMapLineEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapSpline]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapSplineAdapters extends IMapLineAdapters, IMapSplineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a spline on the map.\r\n * \r\n * @see {@link IMapSplineEvents} for a list of available events\r\n * @see {@link IMapSplineAdapters} for a list of available Adapters\r\n */\r\nexport class MapSpline extends MapLine {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t * \r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSplineProperties}\r\n\t */\r\n\tpublic _properties: IMapSplineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSplineAdapters}\r\n\t */\r\n\tpublic _adapter: IMapSplineAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapSpline, IMapSplineEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapSpline, IMapSplineEvents>>;\r\n\r\n\t/**\r\n\t * A visual element for the spline.\r\n\t * \r\n\t * @type {Polyspline}\r\n\t */\r\n\tpublic line: Polyspline;\r\n\r\n\t/**\r\n\t * A related data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapSplineSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapSplineSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapSplineSeries}\r\n\t */\r\n\tpublic series: MapSplineSeries;\t\t\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSpline\";\r\n\r\n\t\t// Create a spline\r\n\t\tthis.line = new Polyspline();\r\n\t\tthis.line.tensionX = 0.8;\r\n\t\tthis.line.tensionY = 0.8;\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\t/**\t \r\n\t * ShortestDistance = true is not supported by MapSpline, only MapLine does support it\r\n\t * @default false\r\n\t * @param {boolean}  value\r\n\t * @todo: review description\r\n\t */\t\r\n\tpublic get shortestDistance():boolean{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic set shortestDistance(value:boolean){\r\n\t\t\r\n\t}\t\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapSpline\"] = MapSpline;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSpline.ts","/**\r\n * Map arched line module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapLine, IMapLineProperties, IMapLineAdapters, IMapLineEvents } from \"./MapLine\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { Polyarc } from \"../../core/elements/Polyarc\";\r\nimport { system } from \"../../core/System\";\r\nimport { MapArcSeries, MapArcSeriesDataItem } from \"./MapArcSeries\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapArc]].\r\n */\r\nexport interface IMapArcProperties extends IMapLineProperties { }\r\n\r\n/**\r\n * Defines events for [[MapArc]].\r\n */\r\nexport interface IMapArcEvents extends IMapLineEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapArc]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapArcAdapters extends IMapLineAdapters, IMapArcProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw an arched line on the map.\r\n * \r\n * @see {@link IMapArcEvents} for a list of available events\r\n * @see {@link IMapArcAdapters} for a list of available Adapters\r\n */\r\nexport class MapArc extends MapLine {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t * \r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapArcProperties}\r\n\t */\r\n\tpublic _properties: IMapArcProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapArcAdapters}\r\n\t */\r\n\tpublic _adapter: IMapArcAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapArc, IMapArcEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapArc, IMapArcEvents>>;\r\n\r\n\t/**\r\n\t * A visual element.\r\n\t * \r\n\t * @type {Polyarc}\r\n\t */\r\n\tpublic line: Polyarc;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t * \r\n\t * @type {MapArcSeries}\r\n\t */\r\n\tpublic series: MapArcSeries;\t\t\t\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapArc\";\r\n\r\n\t\t// Create a line\r\n\t\tthis.line = new Polyarc();\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\r\n\t/**\t \r\n\t * ShortestDistance = true is not supported by MapArc, only MapLine does support it\r\n\t * @default false\r\n\t * @param {boolean}  value\r\n\t * @todo: review description\r\n\t */\t\r\n\tpublic get shortestDistance():boolean{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic set shortestDistance(value:boolean){\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapArc\"] = MapArc;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapArc.ts","/**\r\n * Zoom control module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../../core/Container\";\r\nimport { Sprite, ISpriteEvents, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { Button } from \"../../core/elements/Button\";\r\nimport { Line } from \"../../core/elements/Line\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\r\nimport { MutableValueDisposer, MultiDisposer } from \"../../core/utils/Disposer\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { keyboard } from \"../../core/utils/Keyboard\";\r\nimport { interaction } from \"../../core/interaction/Interaction\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[ZoomControl]].\r\n */\r\nexport interface IZoomControlProperties extends IContainerProperties { }\r\n\r\n/**\r\n * Defines events for [[ZoomControl]].\r\n */\r\nexport interface IZoomControlEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[ZoomControl]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IZoomControlAdapters extends IContainerAdapters, IZoomControlProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a control for zooming the map.\r\n * \r\n * @see {@link IZoomControlEvents} for a list of available events\r\n * @see {@link IZoomControlAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class ZoomControl extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IZoomControlProperties}\r\n\t */\r\n\tpublic _properties: IZoomControlProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IZoomControlAdapters}\r\n\t */\r\n\tpublic _adapter: IZoomControlAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<ZoomControl, IZoomControlEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<ZoomControl, IZoomControlEvents>>;\r\n\r\n\t/**\r\n\t * Zoom in button element.\r\n\t * \r\n\t * @type {Button}\r\n\t */\r\n\tpublic plusButton: Button;\r\n\r\n\t/**\r\n\t * Zoom out button element.\r\n\t * \r\n\t * @type {Button}\r\n\t */\r\n\tpublic minusButton: Button;\r\n\r\n\t/**\r\n\t * A zoom slider background element.\r\n\t * \r\n\t * @type {Container}\r\n\t */\r\n\tpublic slider: Container;\r\n\r\n\t/**\r\n\t * A zoom slider thumb element.\r\n\t * @type {Button}\r\n\t */\r\n\tpublic thumb: Button;\r\n\r\n\t/**\r\n\t * A target map.\r\n\t * \r\n\t * @type {MutableValueDisposer<MapChart>}\r\n\t */\r\n\tprotected _chart: MutableValueDisposer<MapChart> = new MutableValueDisposer<MapChart>();\r\n\r\n\t/**\r\n\t * A type to use for the background element for zoom control.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {RoundedRectangle}\r\n\t */\r\n\tpublic _background: RoundedRectangle;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"ZoomControl\";\r\n\r\n\t\tthis.align = \"right\";\r\n\t\tthis.valign = \"bottom\";\r\n\r\n\t\tthis.layout = \"vertical\";\r\n\t\tthis.padding(5, 5, 5, 5);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tlet plusButton: Button = this.createChild(Button);\r\n\t\tplusButton.label.text = \"+\";\r\n\t\tplusButton.width = percent(100);\r\n\t\tplusButton.padding(5, 5, 5, 5);\r\n\t\tthis.plusButton = plusButton;\r\n\r\n\t\tlet slider: Container = this.createChild(Container);\r\n\t\tslider.width = percent(100);\r\n\t\tslider.background.fill = interfaceColors.getFor(\"alternativeBackground\");\r\n\t\tslider.background.fillOpacity = 0.05;\r\n\t\tslider.background.events.on(\"hit\", this.handleBackgroundClick, this);\r\n\t\tslider.events.on(\"sizechanged\", this.updateThumbSize, this);\r\n\t\tthis.slider = slider;\r\n\r\n\t\tlet thumb: Button = slider.createChild(Button);\r\n\t\tthumb.padding(0, 0, 0, 0);\r\n\t\tthumb.draggable = true;\r\n\t\tthumb.events.on(\"drag\", this.handleThumbDrag, this);\r\n\t\tthis.thumb = thumb;\r\n\r\n\t\tlet minusButton: Button = this.createChild(Button);\r\n\t\tminusButton.label.text = \"-\";\r\n\t\tminusButton.padding(5, 5, 5, 5);\r\n\t\tthis.minusButton = minusButton;\r\n\r\n\t\t// Set roles\r\n\t\tthis.thumb.role = \"slider\";\r\n\t\tthis.thumb.readerLive = \"polite\";\r\n\r\n\t\t// Set reader text\r\n\t\tthis.thumb.readerTitle = this.language.translate(\"Use arrow keys to zoom in and out\");\r\n\t\tthis.minusButton.readerTitle = this.language.translate(\"Press ENTER to zoom in\");\r\n\t\tthis.plusButton.readerTitle = this.language.translate(\"Press ENTER to zoom out\");\r\n\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.events.on(\"propertychanged\", (event) => {\r\n\t\t\tif (event.property == \"layout\") {\r\n\t\t\t\tthis.fixLayout();\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tthis.fixLayout();\r\n\t}\r\n\r\n\tprotected fixLayout() {\r\n\t\tif (this.layout == \"vertical\") {\r\n\t\t\tthis.width = 40;\r\n\t\t\tthis.height = undefined;\r\n\t\t\tthis.minusButton.width = percent(100);\r\n\t\t\tthis.thumb.width = percent(100);\r\n\t\t\tthis.plusButton.width = percent(100);\r\n\t\t\tthis.slider.width = percent(100);\r\n\t\t\tthis.minusButton.marginTop = 1;\r\n\t\t\tthis.plusButton.marginBottom = 2;\r\n\t\t\tthis.slider.height = 0;\r\n\t\t\tthis.minusButton.toFront();\r\n\t\t\tthis.plusButton.toBack();\r\n\t\t\tthis.thumb.minX = 0;\r\n\t\t\tthis.thumb.maxX = 0;\r\n\t\t\tthis.thumb.minY = 0;\t\t\t\r\n\t\t}\r\n\t\telse if (this.layout == \"horizontal\") {\r\n\t\t\tthis.thumb.minX = 0;\r\n\t\t\tthis.thumb.minY = 0;\t\t\t\t\t\t\r\n\t\t\tthis.thumb.maxY = 0;\t\t\t\t\t\t\r\n\t\t\tthis.height = 40;\r\n\t\t\tthis.width = undefined;\r\n\t\t\tthis.minusButton.height = percent(100);\r\n\t\t\tthis.minusButton.width = 30;\r\n\t\t\tthis.thumb.height = percent(100);\r\n\t\t\tthis.thumb.width = undefined;\r\n\t\t\tthis.plusButton.height = percent(100);\r\n\t\t\tthis.plusButton.width = 30;\r\n\t\t\tthis.slider.height = percent(100);\r\n\t\t\tthis.slider.width = 0;\r\n\t\t\tthis.minusButton.marginLeft = 2;\r\n\t\t\tthis.plusButton.marginRight = 2;\t\t\t\r\n\t\t\tthis.minusButton.toBack();\r\n\t\t\tthis.plusButton.toFront();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Handles zoom operation after clicking on the slider background.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {AMEvent<Sprite, ISpriteEvents>[\"hit\"]}  event  Event\r\n\t */\r\n\tpublic handleBackgroundClick(event: AMEvent<Sprite, ISpriteEvents>[\"hit\"]): void {\r\n\t\tlet sprite: Sprite = event.target;\r\n\t\tlet y: number = event.spritePoint.y;\r\n\t\tlet chart: MapChart = this.chart;\r\n\r\n\t\tlet maxPower: number = Math.log(chart.maxZoomLevel) / Math.LN2;\r\n\t\tlet minPower: number = Math.log(chart.minZoomLevel) / Math.LN2;\r\n\r\n\t\tlet power: number = (sprite.pixelHeight - y) / sprite.pixelHeight * (minPower + (maxPower - minPower));\r\n\t\tlet zoomLevel: number = Math.pow(2, power);\r\n\t\tchart.zoomToGeoPoint(chart.zoomGeoPoint, zoomLevel);\r\n\t}\r\n\r\n\t/**\r\n\t * A main chart/map that this zoom control is for.\r\n\t * \r\n\t * @param {MapChart}  chart  Map/chart\r\n\t */\r\n\tpublic set chart(chart: MapChart) {\r\n\t\tthis._chart.set(chart, new MultiDisposer([\r\n\t\t\tchart.events.on(\"maxsizechanged\", this.updateThumbSize, this),\r\n\t\t\tchart.events.on(\"zoomlevelchanged\", this.updateThumb, this),\r\n\t\t\tthis.minusButton.events.on(\"hit\", () => { chart.zoomOut(chart.zoomGeoPoint) }, chart),\r\n\t\t\tinteraction.body.events.on(\"keyup\", (ev) => {\r\n\t\t\t\tif (this.topParent.hasFocused) {\r\n\t\t\t\t\tif (keyboard.isKey(ev.event, \"enter\")) {\r\n\t\t\t\t\t\tif (this.minusButton.isFocused) {\r\n\t\t\t\t\t\t\tchart.zoomOut()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (this.plusButton.isFocused) {\r\n\t\t\t\t\t\t\tchart.zoomIn()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (keyboard.isKey(ev.event, \"plus\")) {\r\n\t\t\t\t\t\tchart.zoomIn();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (keyboard.isKey(ev.event, \"minus\")) {\r\n\t\t\t\t\t\tchart.zoomOut();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, chart),\r\n\t\t\tthis.plusButton.events.on(\"hit\", () => { chart.zoomIn(chart.zoomGeoPoint) }, chart)\r\n\t\t]));\r\n\t}\r\n\r\n\t/**\r\n\t * @return {MapChart} Map/chart\r\n\t */\r\n\tpublic get chart(): MapChart {\r\n\t\treturn this._chart.get();\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the slider's thumb size based on the available zoom space.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateThumbSize(): void {\r\n\t\tlet chart = this.chart;\r\n\t\tif (chart) {\r\n\t\t\tlet slider: Container = this.slider;\r\n\t\t\tlet thumb: Button = this.thumb;\r\n\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\tthumb.minHeight = Math.min(this.slider.pixelHeight, 20);\r\n\t\t\t\tthumb.height = slider.pixelHeight / (chart.maxZoomLevel - chart.minZoomLevel);\r\n\t\t\t\tthumb.maxY = slider.pixelHeight - thumb.pixelHeight;\r\n\r\n\t\t\t\tif (thumb.pixelHeight <= 1) {\r\n\t\t\t\t\tthumb.visible = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthumb.visible = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthumb.minWidth = Math.min(this.slider.pixelWidth, 20);\r\n\t\t\t\tthumb.width = slider.pixelWidth / (chart.maxZoomLevel - chart.minZoomLevel);\r\n\t\t\t\tthumb.maxX = slider.pixelWidth - thumb.pixelWidth;\r\n\r\n\t\t\t\tif (thumb.pixelWidth <= 1) {\r\n\t\t\t\t\tthumb.visible = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthumb.visible = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates thumb according to current zoom position from map.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateThumb(): void {\r\n\t\tlet slider: Container = this.slider;\r\n\t\tlet chart: MapChart = this.chart;\r\n\t\tlet thumb: Button = this.thumb;\r\n\r\n\t\tif (!thumb.isDown) {\r\n\t\t\tlet step: number = Math.log(chart.zoomLevel) / Math.LN2;\r\n\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\tthumb.y = slider.pixelHeight - (slider.pixelHeight - thumb.pixelHeight) * (step + 1) / this.stepCount;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthumb.x = slider.pixelWidth * step / this.stepCount;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the actual map when slider position changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic handleThumbDrag(): void {\r\n\t\tlet slider: Container = this.slider;\r\n\t\tlet chart: MapChart = this.chart;\r\n\t\tlet thumb: Button = this.thumb;\r\n\t\tlet step:number;\r\n\t\tif(this.layout == \"vertical\"){\r\n\t\t\tstep = this.stepCount * (slider.pixelHeight - thumb.pixelY - thumb.pixelHeight) / (slider.pixelHeight - thumb.pixelHeight) - 1;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tstep = this.stepCount * thumb.pixelX / slider.pixelWidth;\t\r\n\t\t}\r\n\t\tlet zoomLevel: number = Math.pow(2, step);\r\n\t\tchart.zoomToGeoPoint(undefined, zoomLevel, false, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the step countfor the slider grid according to map's min and max\r\n\t * zoom level settings.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return {number} Step count\r\n\t */\r\n\tpublic get stepCount(): number {\r\n\t\treturn Math.log(this.chart.maxZoomLevel) / Math.LN2 - Math.log(this.chart.minZoomLevel) / Math.LN2;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a background element for slider control.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return {this} Background\r\n\t */\r\n\tpublic createBackground(): this[\"_background\"] {\r\n\t\treturn new RoundedRectangle();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"ZoomControl\"] = ZoomControl;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/ZoomControl.ts","import * as m from \"../../src/map\";\n(window as any).amcharts4.map = m;\n\n\n// WEBPACK FOOTER //\n// ./map.ts","/**\r\n * Module: map\r\n */\r\n\r\n/**\r\n * Elements: types\r\n */\r\nexport { MapChartDataItem, IMapPolygonDataObject, MapLineType, IMapLineDataObject, IMapImageDataObject, IMapDataObject, IMapChartDataFields, IMapChartProperties, IMapChartEvents, IMapChartAdapters, MapChart } from \"./.internal/charts/types/MapChart\";\r\nexport { SerialChartDataItem, ISerialChartDataFields, ISerialChartProperties, ISerialChartEvents, ISerialChartAdapters, SerialChart } from \"./.internal/charts/types/SerialChart\";\r\n\r\n/**\r\n * Elements: charts\r\n */\r\nexport { ChartDataItem, IChartDataFields, IChartProperties, IChartEvents, IChartAdapters, Chart } from \"./.internal/charts/Chart\";\r\nexport { LegendDataItem, LegendPosition, ILegendDataFields, ILegendProperties, ILegendEvents, ILegendAdapters, ILegendItem, Legend, LegendSettings } from \"./.internal/charts/Legend\";\r\n\r\n/**\r\n * Elements: series\r\n */\r\nexport { SeriesDataItem, ISeriesDataFields, ISeriesProperties, ISeriesEvents, ISeriesAdapters, Series } from \"./.internal/charts/series/Series\";\r\n\r\n/**\r\n * Elements: axes\r\n */\r\nexport { AxisDataItem, IAxisDataFields, IAxisProperties, IAxisEvents, IAxisAdapters, Axis } from \"./.internal/charts/axes/Axis\";\r\nexport { IGridProperties, IGridEvents, IGridAdapters, Grid } from \"./.internal/charts/axes/Grid\";\r\nexport { IAxisTickProperties, IAxisTickEvents, IAxisTickAdapters, AxisTick } from \"./.internal/charts/axes/AxisTick\";\r\nexport { IAxisLabelProperties, IAxisLabelEvents, IAxisLabelAdapters, AxisLabel } from \"./.internal/charts/axes/AxisLabel\";\r\nexport { IAxisLineProperties, IAxisLineEvents, IAxisLineAdapters, AxisLine } from \"./.internal/charts/axes/AxisLine\";\r\nexport { IAxisFillProperties, IAxisFillEvents, IAxisFillAdapters, AxisFill } from \"./.internal/charts/axes/AxisFill\";\r\nexport { IAxisRendererProperties, IAxisRendererEvents, IAxisRendererAdapters, AxisRenderer } from \"./.internal/charts/axes/AxisRenderer\";\r\nexport { IAxisBreakProperties, IAxisBreakEvents, IAxisBreakAdapters, AxisBreak } from \"./.internal/charts/axes/AxisBreak\";\r\n\r\n/**\r\n * Elements: elements\r\n */\r\nexport { ITickProperties, ITickEvents, ITickAdapters, Tick } from \"./.internal/charts/elements/Tick\";\r\nexport { IBulletProperties, IBulletEvents, IBulletAdapters, Bullet } from \"./.internal/charts/elements/Bullet\";\r\nexport { IHeatLegendProperties, IHeatLegendEvents, IHeatLegendAdapters, HeatLegend } from \"./.internal/charts/elements/HeatLegend\";\r\nexport { ILabelBulletProperties, ILabelBulletEvents, ILabelBulletAdapters, LabelBullet } from \"./.internal/charts/elements/LabelBullet\";\r\nexport { ICircleBulletProperties, ICircleBulletEvents, ICircleBulletAdapters, CircleBullet } from \"./.internal/charts/elements/CircleBullet\";\r\n\r\n/**\r\n * Elements: map\r\n */\r\nexport { MapSeriesDataItem, GEOJSONGeometry, IMapSeriesDataFields, IMapSeriesProperties, IMapSeriesEvents, IMapSeriesAdapters, MapSeries } from \"./.internal/charts/map/MapSeries\";\r\nexport { IMapObjectProperties, IMapObjectEvents, IMapObjectAdapters, MapObject } from \"./.internal/charts/map/MapObject\";\r\nexport { IMapPolygonProperties, IMapPolygonEvents, IMapPolygonAdapters, MapPolygon } from \"./.internal/charts/map/MapPolygon\";\r\nexport { IMapImageProperties, IMapImageEvents, IMapImageAdapters, MapImage } from \"./.internal/charts/map/MapImage\";\r\nexport { IMapLineProperties, IMapLineEvents, IMapLineAdapters, MapLine } from \"./.internal/charts/map/MapLine\";\r\nexport { IMapSplineProperties, IMapSplineEvents, IMapSplineAdapters, MapSpline } from \"./.internal/charts/map/MapSpline\";\r\nexport { IMapArcProperties, IMapArcEvents, IMapArcAdapters, MapArc } from \"./.internal/charts/map/MapArc\";\r\n\r\nexport { MapPolygonSeriesDataItem, IMapPolygonSeriesDataFields, IMapPolygonSeriesProperties, IMapPolygonSeriesEvents, IMapPolygonSeriesAdapters, MapPolygonSeries } from \"./.internal/charts/map/MapPolygonSeries\";\r\nexport { MapLineSeriesDataItem, IMapLineSeriesDataFields, IMapLineSeriesProperties, IMapLineSeriesEvents, IMapLineSeriesAdapters, MapLineSeries } from \"./.internal/charts/map/MapLineSeries\";\r\nexport { MapSplineSeriesDataItem, IMapSplineSeriesDataFields, IMapSplineSeriesProperties, IMapSplineSeriesEvents, IMapSplineSeriesAdapters, MapSplineSeries } from \"./.internal/charts/map/MapSplineSeries\";\r\nexport { MapImageSeriesDataItem, IMapImageSeriesDataFields, IMapImageSeriesProperties, IMapImageSeriesEvents, IMapImageSeriesAdapters, MapImageSeries } from \"./.internal/charts/map/MapImageSeries\";\r\nexport { MapArcSeriesDataItem, IMapArcSeriesDataFields, IMapArcSeriesProperties, IMapArcSeriesEvents, IMapArcSeriesAdapters, MapArcSeries } from \"./.internal/charts/map/MapArcSeries\";\r\nexport { multiPolygonToGeo, multiLineToGeo, multiPointToGeo, pointToGeo } from \"./.internal/charts/map/MapUtils\";\r\nexport { IZoomControlProperties, IZoomControlEvents, IZoomControlAdapters, ZoomControl } from \"./.internal/charts/map/ZoomControl\";\r\nexport { ISmallMapProperties, ISmallMapEvents, ISmallMapAdapters, SmallMap } from \"./.internal/charts/map/SmallMap\";\r\n\r\n\r\n/**\r\n * Elements: projections\r\n */\r\nexport { Projection } from \"./.internal/charts/map/projections/Projection\";\r\nimport * as projections from \"./.internal/charts/map/projections\";\r\nexport { projections };\r\n\r\n\r\nimport * as geo from \"./.internal/charts/map/Geo\";\r\nexport { geo };\r\n\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/map.ts","/**\r\n * Map module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { SerialChart, ISerialChartProperties, ISerialChartDataFields, ISerialChartAdapters, ISerialChartEvents, SerialChartDataItem } from \"./SerialChart\";\r\nimport { Sprite, ISpriteEvents, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { Container } from \"../../core/Container\";\r\nimport { ListTemplate } from \"../../core/utils/List\";\r\nimport { MapSeries } from \"../map/MapSeries\";\r\nimport { MapObject } from \"../map/MapObject\";\r\nimport { MapImage } from \"../map/MapImage\";\r\nimport { MapPolygon } from \"../map/MapPolygon\";\r\nimport { MapLine } from \"../map/MapLine\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Circle } from \"../../core/elements/Circle\";\r\nimport { Projection } from \"../map/projections/Projection\";\r\nimport { ZoomControl } from \"../map/ZoomControl\";\r\nimport { Ordering } from \"../../core/utils/Order\";\r\nimport { SmallMap } from \"../map/SmallMap\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { keyboard } from \"../../core/utils/Keyboard\";\r\nimport { interaction } from \"../../core/interaction/Interaction\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $ease from \"../../core/utils/Ease\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $geo from \"../map/Geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapChart]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class MapChartDataItem extends SerialChartDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t *\r\n\t * @type {MapChart}\r\n\t */\r\n\tpublic _component: MapChart;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapChartDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines interface for a map polygon object.\r\n */\r\nexport interface IMapPolygonDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t *\r\n\t * @type {[type]}\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Single polygon information in X/Y coordinates.\r\n\t */\r\n\tpolygon?: number[][][];\r\n\r\n\t/**\r\n\t * Multi-part polygon information in X/Y coordinates.\r\n\t */\r\n\tmultiPolygon?: number[][][][];\r\n\r\n\t/**\r\n\t * Single polygon information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoPolygon?: IGeoPoint[][];\r\n\r\n\t/**\r\n\t * Multi-part polygon information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoPolygon?: IGeoPoint[][][];\r\n\r\n}\r\n\r\n/**\r\n * Defines types of map line.\r\n *\r\n * @type {string}\r\n */\r\nexport type MapLineType = \"line\" | \"arc\" | \"spline\" | \"realTrajectory\";\r\n\r\n/**\r\n * Defines interface for the map line object.\r\n */\r\nexport interface IMapLineDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t *\r\n\t * @type {[type]}\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Single line information in X/Y coordinates.\r\n\t */\r\n\tlineString?: number[][];\r\n\r\n\t/**\r\n\t * Multi-part line information in X/Y coordinates.\r\n\t */\r\n\tmultiLineString?: number[][][];\r\n\r\n\t/**\r\n\t * Single line information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoLineString?: IGeoPoint[];\r\n\r\n\t/**\r\n\t * Multi-part line information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoLineString?: IGeoPoint[][];\r\n\r\n}\r\n\r\n/**\r\n * Defines interface for a map image (market) object.\r\n */\r\nexport interface IMapImageDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t *\r\n\t * @type {[type]}\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Image position information in X/Y coordinates.\r\n\t */\r\n\tpoint?: number[];\r\n\r\n\t/**\r\n\t * Multi-image position information in X/Y coordinates.\r\n\t */\r\n\tmultiPoint?: number[][];\r\n\r\n\t/**\r\n\t * Image position information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoPoint?: IGeoPoint;\r\n\r\n\t/**\r\n\t * Multi-image position information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoPoint?: IGeoPoint[];\r\n\r\n}\r\n\r\n/**\r\n * Defines type suitable for all map objects.\r\n *\r\n * @type {IMapPolygonDataObject | IMapLineDataObject}\r\n */\r\nexport type IMapDataObject = IMapPolygonDataObject | IMapLineDataObject;\r\n\r\n/**\r\n * Defines data fields for [[MapChart]].\r\n */\r\nexport interface IMapChartDataFields extends ISerialChartDataFields { }\r\n\r\n/**\r\n * Defines properties for [[MapChart]].\r\n */\r\nexport interface IMapChartProperties extends ISerialChartProperties {\r\n\r\n\t/**\r\n\t * Projection to be used when drawing the map\r\n\t * @type {Projection}\r\n\t */\r\n\tprojection?: Projection;\r\n\r\n\t/**\r\n\t * [deltaLatitude description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number}\r\n\t */\r\n\tdeltaLatitude?: number;\r\n\r\n\t/**\r\n\t * [deltaLongitude description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number}\r\n\t */\r\n\tdeltaLongitude?: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[MapChart]].\r\n */\r\nexport interface IMapChartEvents extends ISerialChartEvents {\r\n\r\n\t/**\r\n\t * Invoked when map is zoomed in or out.\r\n\t */\r\n\tzoomlevelchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when map is panned. (moved)\r\n\t */\r\n\tmappositionchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when scale ratio is changed, e.g when the whole map area is\r\n\t * resized and the map needs to be resized to fit it, without changing\r\n\t * zoom level.\r\n\t */\r\n\tscaleratiochanged: {};\r\n\r\n}\r\n\r\n/**\r\n * Defines adapters for [[MapChart]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapChartAdapters extends ISerialChartAdapters, IMapChartProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a map.\r\n *\r\n * @see {@link IMapChartEvents} for a list of available Events\r\n * @see {@link IMapChartAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\r\nexport class MapChart extends SerialChart {\r\n\r\n\t/**\r\n\t * Available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapChartDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapChartDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapChartProperties}\r\n\t */\r\n\tpublic _properties: IMapChartProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapChartAdapters}\r\n\t */\r\n\tpublic _adapter: IMapChartAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t *\r\n\t * @type {SpriteEventDispatcher<AMEvent<MapChart, IMapChartEvents>>}\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapChart, IMapChartEvents>>;\r\n\r\n\t/**\r\n\t * The East-most longitude point of the map.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic east: number;\r\n\r\n\t/**\r\n\t * The West-most longitude point of the map.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic west: number;\r\n\r\n\t/**\r\n\t * The South-most latitude point of the map.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic south: number;\r\n\r\n\t/**\r\n\t * The North-most latitude point of the map.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic north: number;\r\n\r\n\t/**\r\n\t * A ratio to be used when scaling the map shapes.\r\n\t *\r\n\t * @readonly\r\n\t * @type {number}\r\n\t */\r\n\tpublic scaleRatio: number = 1;\r\n\r\n\t/**\r\n\t * A screen point of the map's center.\r\n\t *\r\n\t * @readonly\r\n\t * @type {IPoint}\r\n\t */\r\n\tpublic centerPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's left.\r\n\t *\r\n\t * @readonly\r\n\t * @type {IPoint}\r\n\t */\r\n\tpublic westPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's right.\r\n\t *\r\n\t * @readonly\r\n\t * @type {IPoint}\r\n\t */\r\n\tpublic eastPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's top.\r\n\t *\r\n\t * @readonly\r\n\t * @type {IPoint}\r\n\t */\r\n\tpublic northPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's bottom.\r\n\t *\r\n\t * @readonly\r\n\t * @type {IPoint}\r\n\t */\r\n\tpublic southPoint: IPoint;\r\n\r\n\t/**\r\n\t * Width of the actual map objects. (px)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic seriesWidth: number;\r\n\r\n\t/**\r\n\t * Height of the actual map objects. (px)\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic seriesHeight: number;\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * @see {@link http://geojson.org/} GeoJSON official specification\r\n\t * @type {Object}\r\n\t */\r\n\tprotected _geoJSON: Object;\r\n\r\n\t/**\r\n\t * A reference to a [[ZoomControl]] instance.\r\n\t *\r\n\t * @type {ZoomControl}\r\n\t */\r\n\tprotected _zoomControl: ZoomControl;\r\n\r\n\t/**\r\n\t * A reference to a [[SmallMap]] control instance.\r\n\t *\r\n\t * @type {SmallMap}\r\n\t */\r\n\tprotected _smallMap: SmallMap;\r\n\r\n\t/**\r\n\t * [_zoomGeoPoint description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {IGeoPoint}\r\n\t */\r\n\tprotected _zoomGeoPoint: IGeoPoint;\r\n\r\n\t/**\r\n\t * Default duration of zoom animations (ms).\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic zoomDuration: number = 1000;\r\n\r\n\t/**\r\n\t * Default zooming animation easing function.\r\n\t *\r\n\t * @type {function}\r\n\t */\r\n\tpublic zoomEasing: (value: number) => number = $ease.cubicOut;\r\n\r\n\t/**\r\n\t * Smallest available zoom level. The map will not allow to zoom out past\r\n\t * this setting.\r\n\t *\r\n\t * NOTE: Should be power of 2.\r\n\t *\r\n\t * @defautl 1\r\n\t * @type {number}\r\n\t */\r\n\tpublic minZoomLevel: number = 1;\r\n\r\n\t/**\r\n\t * Biggest available zoom level. The map will not allow to zoom in past\r\n\t * this setting.\r\n\t *\r\n\t * NOTE: Should be power of 2.\r\n\t *\r\n\t * @default 32\r\n\t * @type {number}\r\n\t */\r\n\tpublic maxZoomLevel: number = 32;\r\n\r\n\t/**\r\n\t * [_prevZoomLevel description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number}\r\n\t */\r\n\tprotected _prevZoomLevel: number;\r\n\r\n\t/**\r\n\t * [_prevZoomGeoPoint description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {IGeoPoint}\r\n\t */\r\n\tprotected _prevZoomGeoPoint: IGeoPoint = { latitude: 0, longitude: 0 };\r\n\r\n\t/**\r\n\t * List of series of map objects. (lines, areas, etc.)\r\n\t *\r\n\t * @type {ListTemplate<MapSeries>}\r\n\t */\r\n\tpublic series: ListTemplate<MapSeries>;\r\n\r\n\t/**\r\n\t * A reference to currently playing animation, e.g. zooming.\r\n\t *\r\n\t * @type {Animation}\r\n\t */\r\n\tprotected _mapAnimation: Animation;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapChart\";\r\n\r\n\t\t// Set default projection\r\n\t\tthis.projection = new Projection();\r\n\r\n\t\t//\t\tthis.deltaLatitude = 0;\r\n\t\tthis.deltaLongitude = 0;\r\n\r\n\t\t// Set padding\r\n\t\tthis.padding(0, 0, 0, 0);\r\n\r\n\t\t// Create a container for map series\r\n\t\tlet seriesContainer = this.seriesContainer;\r\n\t\tseriesContainer.draggable = true;\r\n\t\tseriesContainer.inert = true;\r\n\t\tseriesContainer.resizable = true;\r\n\t\tseriesContainer.events.on(\"transformed\", this.handleMapTransform, this);\r\n\t\tseriesContainer.events.on(\"doublehit\", this.handleDoubleHit, this);\r\n\r\n\t\t// Set up events\r\n\t\tthis.events.on(\"datavalidated\", this.updateExtremes, this);\r\n\r\n\t\t// Set up main chart container, e.g. set backgrounds and events to monitor\r\n\t\t// size changes, etc.\r\n\t\tlet chartContainer = this.chartContainer;\r\n\t\tchartContainer.events.on(\"maxsizechanged\", this.udpateScaleRatio, this);\r\n\r\n\t\tlet chartContainerBg = chartContainer.background;\r\n\t\tchartContainerBg.fillOpacity = 0;\r\n\t\tchartContainerBg.events.on(\"down\", (e) => { this.seriesContainer.dragStart(e.target.interactions.downPointers.getIndex(0)); }, this);\r\n\t\tchartContainerBg.events.on(\"up\", (e) => { this.seriesContainer.dragStop() }, this);\r\n\t\tchartContainerBg.events.on(\"doublehit\", this.handleDoubleHit, this);\r\n\t\tchartContainerBg.focusable = true;\r\n\r\n\t\tchartContainer.events.on(\"wheel\", this.handleWheel, this);\r\n\t\tchartContainer.events.on(\"down\", this.handleMapDown, this);\r\n\r\n\t\t// Add description to background\r\n\t\tthis.background.fillOpacity = 0;\r\n\t\tthis.background.readerTitle = this.language.translate(\"Use plus and minus keys on your keyboard to zoom in and out\");\r\n\r\n\t\t// Add keyboard events for panning\r\n\t\tinteraction.body.events.on(\"keyup\", (ev) => {\r\n\t\t\tif (this.topParent.hasFocused && (!this._zoomControl || !this._zoomControl.thumb.isFocused)) {\r\n\t\t\t\tswitch (keyboard.getEventKey(ev.event)) {\r\n\t\t\t\t\tcase \"up\":\r\n\t\t\t\t\t\tthis.pan({ x: 0, y: 0.1 });\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"down\":\r\n\t\t\t\t\t\tthis.pan({ x: 0, y: -0.1 });\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\tthis.pan({ x: 0.1, y: 0 });\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\tthis.pan({ x: -0.1, y: 0 });\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, this);\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Add a default screen reader title for accessibility\r\n\t\t// This will be overridden in screen reader if there are any `titles` set\r\n\t\tthis.readerTitle = this.language.translate(\"Map\");\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when a pointer presses down on the map, e.g. user presses\r\n\t * down mouse or touches the map on a screen.\r\n\t *\r\n\t * Stops all animations currently going on.\r\n\t */\r\n\tprotected handleMapDown(): void {\r\n\t\tif (this._mapAnimation) {\r\n\t\t\tthis._mapAnimation.stop();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles the event when user doubleclicks or dooubletaps the map: zooms\r\n\t * in on the reference point.\r\n\t *\r\n\t * @param {AMEvent<Sprite, ISpriteEvents>[\"doublehit\"]}  event  Original event\r\n\t */\r\n\tprotected handleDoubleHit(event: AMEvent<Sprite, ISpriteEvents>[\"doublehit\"]) {\r\n\t\tlet svgPoint: IPoint = $utils.documentPointToSvg(event.point, this.htmlContainer);\r\n\t\tlet geoPoint: IGeoPoint = this.svgPointToGeo(svgPoint);\r\n\t\tthis.zoomIn(geoPoint);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles mouse wheel event, e.g. user rotates mouse wheel while over the\r\n\t * map: zooms in or out depending on the direction of the wheel turn.\r\n\t *\r\n\t * @param {AMEvent<Sprite, ISpriteEvents>[\"wheel\"]}  event  Original event\r\n\t */\r\n\tprotected handleWheel(event: AMEvent<Sprite, ISpriteEvents>[\"wheel\"]) {\r\n\r\n\t\tlet svgPoint: IPoint = $utils.documentPointToSvg(event.point, this.htmlContainer);\r\n\t\tlet geoPoint: IGeoPoint = this.svgPointToGeo(svgPoint);\r\n\r\n\t\tif (event.shift.y < 0) {\r\n\t\t\tthis.zoomIn(geoPoint);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.zoomOut(geoPoint);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Projection to use for the map.\r\n\t *\r\n\t * Available projections:\r\n\t * * Eckert6\r\n\t * * Mercator\r\n\t * * Miller\r\n\t * * Orthographic\r\n\t *\r\n\t * ```TypeScript\r\n\t * map.projection = new map.projections.Mercator();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * map1.projection = new amcharts4.map.projections.Mercator();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"projection\": \"Mercator\"\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param {Projection}  projection  Projection\r\n\t */\r\n\tpublic set projection(projection: Projection) {\r\n\t\tthis.setPropertyValue(\"projection\", projection, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Projection} Projection\r\n\t */\r\n\tpublic get projection(): Projection {\r\n\t\treturn this.getPropertyValue(\"projection\");\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the longitudes and latitudes of the most distant points from\r\n\t * the center in all four directions: West, East, North, and South.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateExtremes(): void {\r\n\r\n\t\tthis.west = null;\r\n\t\tthis.east = null;\r\n\t\tthis.north = null;\r\n\t\tthis.south = null;\r\n\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tif ((this.west > series.west) || !$type.isNumber(this.west)) {\r\n\t\t\t\tthis.west = series.west;\r\n\t\t\t}\r\n\t\t\tif ((this.east < series.east) || !$type.isNumber(this.east)) {\r\n\t\t\t\tthis.east = series.east;\r\n\t\t\t}\r\n\r\n\t\t\tif ((this.north < series.north) || !$type.isNumber(this.north)) {\r\n\t\t\t\tthis.north = series.north;\r\n\t\t\t}\r\n\t\t\tif ((this.south > series.south) || !$type.isNumber(this.south)) {\r\n\t\t\t\tthis.south = series.south;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// must reset\r\n\t\tthis.projection.centerPoint = { x: 0, y: 0 };\r\n\t\tthis.projection.scale = 1;\r\n\r\n\t\t// temporary setting deltaLongitude to 0 in order to measure w/h correctly\r\n\t\tlet deltaLongitude = this.projection.deltaLongitude;\r\n\t\tthis.projection.deltaLongitude = 0;\r\n\t\tlet westPoint: IPoint = this.projection.convert({ longitude: this.west, latitude: (this.south - this.north) / 2 });\r\n\t\tlet eastPoint: IPoint = this.projection.convert({ longitude: this.east, latitude: (this.south - this.north) / 2 });\r\n\r\n\t\tlet northPoint: IPoint = this.projection.convert({ longitude: (this.east - this.west) / 2, latitude: this.north });\r\n\t\tlet southPoint: IPoint = this.projection.convert({ longitude: (this.east - this.west) / 2, latitude: this.south });\r\n\t\tthis.projection.deltaLongitude = deltaLongitude;\r\n\r\n\t\tthis.projection.centerPoint = { x: westPoint.x + (eastPoint.x - westPoint.x) / 2, y: northPoint.y + (southPoint.y - northPoint.y) / 2 };\r\n\r\n\t\tlet scaleRatio: number;\r\n\r\n\t\tlet seriesWidth = eastPoint.x - westPoint.x;\r\n\t\tlet seriesHeight = southPoint.y - northPoint.y;\r\n\r\n\t\tlet vScale: number = this.chartContainer.innerWidth / seriesWidth;\r\n\t\tlet hScale: number = this.chartContainer.innerHeight / seriesHeight;\r\n\r\n\t\tif (vScale > hScale) {\r\n\t\t\tscaleRatio = hScale;\r\n\t\t} else {\r\n\t\t\tscaleRatio = vScale;\r\n\t\t}\r\n\r\n\t\tif ($type.isNaN(scaleRatio) || scaleRatio == Infinity) {\r\n\t\t\tscaleRatio = 1;\r\n\t\t}\r\n\r\n\t\tthis.projection.scale = scaleRatio;\r\n\t\tthis.seriesWidth = seriesWidth * scaleRatio;\r\n\t\tthis.seriesHeight = seriesHeight * scaleRatio;\r\n\r\n\t\tthis.udpateScaleRatio();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)calculates a ratio which should be used to scale the actual map so\r\n\t * that it fits perfectly into available space. Helps to avoid redrawing of all the map if container size changes\r\n\t * @ignore\r\n\t */\r\n\tprotected udpateScaleRatio(): void {\r\n\t\tlet scaleRatio: number;\r\n\r\n\t\tlet vScale: number = this.chartContainer.innerWidth / this.seriesWidth;\r\n\t\tlet hScale: number = this.chartContainer.innerHeight / this.seriesHeight;\r\n\r\n\t\tif (vScale > hScale) {\r\n\t\t\tscaleRatio = hScale;\r\n\t\t} else {\r\n\t\t\tscaleRatio = vScale;\r\n\t\t}\r\n\r\n\t\tif ($type.isNaN(scaleRatio) || scaleRatio == Infinity) {\r\n\t\t\tscaleRatio = 1;\r\n\t\t}\r\n\r\n\t\tif (scaleRatio != this.scaleRatio) {\r\n\t\t\tthis.scaleRatio = scaleRatio;\r\n\r\n\t\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\t\tseries.scale = this.scaleRatio;\r\n\t\t\t});\r\n\r\n\t\t\tthis.dispatch(\"scaleratiochanged\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a point within map container to geographical (lat/long)\r\n\t * coordinates.\r\n\t *\r\n\t * @param  {IPoint}     point  Source point\r\n\t * @return {IGeoPoint}         Geo-point\r\n\t */\r\n\tpublic svgPointToGeo(point: IPoint): IGeoPoint {\r\n\t\tlet series: MapSeries = <MapSeries>this.series.getIndex(0);\r\n\t\tif (series) {\r\n\t\t\tlet seriesPoint: IPoint = $utils.svgPointToSprite(point, series);\r\n\t\t\treturn this.seriesPointToGeo(seriesPoint);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical (lat/long) coordinates to an X/Y point within map's\r\n\t * container.\r\n\t *\r\n\t * @param  {IGeoPoint}  point  Source geo-point\r\n\t * @return {IPoint}            Point\r\n\t */\r\n\tpublic geoPointToSVG(point: IGeoPoint): IPoint {\r\n\t\tlet series: MapSeries = <MapSeries>this.series.getIndex(0);\r\n\t\tif (series) {\r\n\t\t\tlet seriesPoint: IPoint = this.geoPointToSeries(point);\r\n\t\t\treturn $utils.spritePointToSvg(seriesPoint, series);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a point (X/Y) within actual objects of the map to geographical\r\n\t * (lat/long) coordinates.\r\n\t *\r\n\t * @param  {IPoint}     point  Source point\r\n\t * @return {IGeoPoint}         Geo-point\r\n\t */\r\n\tpublic seriesPointToGeo(point: IPoint): IGeoPoint {\r\n\t\treturn this.projection.invert(point);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical (lat/long) coordinates to an X/Y point within\r\n\t * actual elements/objects of the maps.\r\n\t *\r\n\t * @param  {IGeoPoint}  point  Source geo-point\r\n\t * @return {IPoint}            Point\r\n\t */\r\n\tpublic geoPointToSeries(point: IGeoPoint): IPoint {\r\n\t\treturn this.projection.convert(point);\r\n\t}\r\n\r\n\t/**\r\n\t * Performs after-draw tasks, e.g. centers the map.\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\tsuper.afterDraw();\r\n\t\tlet seriesContainer: Container = this.seriesContainer;\r\n\t\tlet chartContainer: Container = this.chartContainer;\r\n\r\n\t\tseriesContainer.x = chartContainer.pixelWidth / 2;\r\n\t\tseriesContainer.y = chartContainer.pixelHeight / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * The Map supports the following GeoJSON objects: `Point`, `LineString`,\r\n\t * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n\t *\r\n\t * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n\t * @param {Object} geoJSON GeoJSON data\r\n\t */\r\n\tpublic set geoJSON(geoJSON: Object) {\r\n\t\tif (geoJSON != this._geoJSON) {\r\n\t\t\tthis._geoJSON = geoJSON;\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Object} GeoJSON data\r\n\t */\r\n\tpublic get geoJSON(): Object {\r\n\t\treturn this._geoJSON;\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to particular zoom level and centers on a latitude/longitude\r\n\t * coordinate.\r\n\t *\r\n\t * @param  {IGeoPoint}  point      Center coordinate\r\n\t * @param  {number}     zoomLevel  Zoom level\r\n\t * @param  {boolean}    center     Center on the given coordinate?\r\n\t * @param  {number}     duration   Duration for zoom animation (ms)\r\n\t * @return {Animation}             Zoom animation\r\n\t */\r\n\tpublic zoomToGeoPoint(point: IGeoPoint, zoomLevel: number, center?: boolean, duration?: number): Animation {\r\n\t\tif (!point) {\r\n\t\t\tpoint = this.zoomGeoPoint;\r\n\t\t}\r\n\t\tzoomLevel = $math.fitToRange(zoomLevel, this.minZoomLevel, this.maxZoomLevel);\r\n\r\n\t\tlet seriesPoint: IPoint = this.projection.convert(point);\r\n\r\n\t\tlet svgPoint: IPoint = this.geoPointToSVG(point);\r\n\t\tif (center) {\r\n\t\t\tsvgPoint = {\r\n\t\t\t\tx: this.pixelWidth / 2,\r\n\t\t\t\ty: this.pixelHeight / 2\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(duration)) {\r\n\t\t\tduration = this.zoomDuration;\r\n\t\t}\r\n\r\n\t\tthis._mapAnimation = this.seriesContainer.animate(\r\n\t\t\t[{\r\n\t\t\t\tproperty: \"scale\",\r\n\t\t\t\tto: zoomLevel\r\n\t\t\t}, {\r\n\t\t\t\tproperty: \"x\",\r\n\t\t\t\tto: svgPoint.x - seriesPoint.x * zoomLevel * this.scaleRatio - this.pixelPaddingLeft\r\n\t\t\t}, {\r\n\t\t\t\tproperty: \"y\",\r\n\t\t\t\tto: svgPoint.y - seriesPoint.y * zoomLevel * this.scaleRatio - this.pixelPaddingTop\r\n\t\t\t}], duration, this.zoomEasing);\r\n\t\treturn this._mapAnimation;\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to a particular map object.\r\n\t *\r\n\t * @param  {MapObject}  mapObject  Target map object\r\n\t * @param  {number}     zoomLevel  Zoom level\r\n\t * @param  {boolean}    center     Center on the given coordinate?\r\n\t * @param  {number}     duration   Duration for zoom animation (ms)\r\n\t * @return {Animation}             Zoom animation\r\n\t */\r\n\tpublic zoomToMapObject(mapObject: MapObject, zoomLevel?: number, center?: boolean, duration?: number): Animation {\r\n\r\n\t\tif (center == undefined) {\r\n\t\t\tcenter = true;\r\n\t\t}\r\n\r\n\t\tif (mapObject instanceof MapImage) {\r\n\t\t\tif ($type.isNaN(zoomLevel)) {\r\n\t\t\t\tzoomLevel = 5;\r\n\t\t\t}\r\n\t\t\treturn this.zoomToGeoPoint({ latitude: mapObject.latitude, longitude: mapObject.longitude }, zoomLevel, center, duration);\r\n\t\t}\r\n\r\n\t\tif (mapObject instanceof MapPolygon) {\r\n\t\t\tlet dataItem = mapObject.dataItem;\r\n\t\t\treturn this.zoomToRectangle(dataItem.north, dataItem.east, dataItem.south, dataItem.west, zoomLevel, center, duration);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to a particular viewport.\r\n\t *\r\n\t * The `north`, `east`, `south`, and `west` define boundaries of the\r\n\t * imaginary viewort we want to zoom the map to.\r\n\t *\r\n\t * `level` is not actual zoom level. The map will determine the zoom level\r\n\t * required to accommodated such zoom, and will adjust it by `level` if set.\r\n\t *\r\n\t * @param  {number}     north     Latitude of the North-most boundary\r\n\t * @param  {number}     east      Longitude of the East-most boundary\r\n\t * @param  {number}     south     Latitude of the South-most boundary\r\n\t * @param  {number}     west      Longitude of the West-most boundary\r\n\t * @param  {number}     level     Adjust zoom level\r\n\t * @param  {boolean}    center    Center on the given coordinate?\r\n\t * @param  {number}     duration  Duration for zoom animation (ms)\r\n\t * @return {Animation}            Zoom animation\r\n\t */\r\n\tpublic zoomToRectangle(north: number, east: number, south: number, west: number, level?: number, center?: boolean, duration?: number): Animation {\r\n\t\tif ($type.isNaN(level)) {\r\n\t\t\tlevel = 1;\r\n\t\t}\r\n\r\n\t\tlet zoomLevel = level * Math.min((this.south - this.north) / (south - north), (this.west - this.east) / (west - east));\r\n\r\n\t\treturn this.zoomToGeoPoint({ latitude: north + (south - north) / 2, longitude: west + (east - west) / 2 }, zoomLevel, center, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms in the map, optionally centering on particular latitude/longitude\r\n\t * point.\r\n\t *\r\n\t * @param  {IGeoPoint}  geoPoint  Optional center point\r\n\t * @param  {number}     duration  Duration for zoom animation (ms)\r\n\t * @return {Animation}            Zoom animation\r\n\t */\r\n\tpublic zoomIn(geoPoint?: IGeoPoint, duration?: number): Animation {\r\n\t\treturn this.zoomToGeoPoint(geoPoint, this.zoomLevel * 2, false, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms out the map, optionally centering on particular latitude/longitude\r\n\t * point.\r\n\t *\r\n\t * @param  {IGeoPoint}  geoPoint  Optional center point\r\n\t * @param  {number}     duration  Duration for zoom animation (ms)\r\n\t * @return {Animation}            Zoom animation\r\n\t */\r\n\tpublic zoomOut(geoPoint?: IGeoPoint, duration?: number): Animation {\r\n\t\treturn this.zoomToGeoPoint(geoPoint, this.zoomLevel / 2, false, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Pans the maps using relative coordinates. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * {\r\n\t *   x: 0.1,\r\n\t *   y: -0.1\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will move the map by 10% to the right, and by 10% upwards.\r\n\t *\r\n\t * @param {IPoint}  shift     Vertical and horizontal shift\r\n\t * @param {number}  duration  Pan animation duration (ms)\r\n\t */\r\n\tpublic pan(shift: IPoint, duration?: number): void {\r\n\t\tlet point = this.geoPointToSVG(this.zoomGeoPoint);\r\n\t\tpoint.x += this.pixelWidth * shift.x;\r\n\t\tpoint.y += this.pixelHeight * shift.y;\r\n\t\tthis.zoomToGeoPoint(this.svgPointToGeo(point), this.zoomLevel, true, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Current lat/long coordinates for the center of the viewport. (default\r\n\t * zoom reference point)\r\n\t *\r\n\t * @readonly\r\n\t * @return {IGeoPoint} Coordinates\r\n\t */\r\n\tpublic get zoomGeoPoint(): IGeoPoint {\r\n\t\treturn this.svgPointToGeo({\r\n\t\t\tx: this.pixelWidth / 2,\r\n\t\t\ty: this.pixelHeight / 2\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Current zoom level.\r\n\t *\r\n\t * @readonly\r\n\t * @return {number} Zoom level\r\n\t */\r\n\tpublic get zoomLevel(): number {\r\n\t\treturn this.seriesContainer.scale;\r\n\t}\r\n\r\n\tpublic set zoomLevel(value: number) {\r\n\t\tthis.seriesContainer.scale = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches events after some map transformation, like pan or zoom.\r\n\t */\r\n\tprotected handleMapTransform(): void {\r\n\t\tif (this.zoomLevel != this._prevZoomLevel) {\r\n\t\t\tthis.dispatch(\"zoomlevelchanged\");\r\n\t\t}\r\n\r\n\t\tif (this.zoomGeoPoint && (this._prevZoomGeoPoint.latitude != this.zoomGeoPoint.latitude || this._prevZoomGeoPoint.longitude != this.zoomGeoPoint.longitude)) {\r\n\t\t\tthis.dispatch(\"mappositionchanged\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A [[SmallMap]] to be used on the map.\r\n\t *\r\n\t * Please note, that accessing this property will NOT create a small map\r\n\t * if it has not yet been created. (except in JSON)\r\n\t *\r\n\t * ```TypeScript\r\n\t * // Create a small map\r\n\t * map.smallMap = new map.SmallMap();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * // Create a small map\r\n\t * map.smallMap = new amcharts4.map.SmallMap();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"smallMap\": {}\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param {SmallMap}  smallMap  Small map\r\n\t */\r\n\tpublic set smallMap(smallMap: SmallMap) {\r\n\t\tif (this._smallMap) {\r\n\t\t\tthis.removeDispose(this._smallMap);\r\n\t\t}\r\n\t\tthis._smallMap = smallMap;\r\n\t\tthis._smallMap.chart = this;\r\n\t\tsmallMap.parent = this.chartContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {SmallMap} Small map\r\n\t */\r\n\tpublic get smallMap(): SmallMap {\r\n\t\tif (!this._smallMap) {\r\n\t\t\tlet smallMap: SmallMap = new SmallMap();\r\n\t\t\tthis.smallMap = smallMap;\r\n\t\t}\r\n\t\treturn this._smallMap;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[ZoomControl]] to be used on the map.\r\n\t *\r\n\t * Please note, that accessing this property will NOT create a zoom control\r\n\t * if it has not yet been created. (except in JSON)\r\n\t *\r\n\t * ```TypeScript\r\n\t * // Create a zoom control\r\n\t * map.zoomControl = new map.ZoomControl();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * // Create a zoom control\r\n\t * map.zoomControl = new amcharts4.map.ZoomControl();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"zoomControl\": {}\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param {ZoomControl}  zoomControl  Zoom control\r\n\t */\r\n\tpublic set zoomControl(zoomControl: ZoomControl) {\r\n\t\tif (this._zoomControl) {\r\n\t\t\tthis.removeDispose(this._zoomControl);\r\n\t\t}\r\n\t\tthis._zoomControl = zoomControl;\r\n\t\tzoomControl.chart = this;\r\n\t\tzoomControl.parent = this.chartContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {ZoomControl} Zoom control\r\n\t */\r\n\tpublic get zoomControl(): ZoomControl {\r\n\t\treturn this._zoomControl;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates and returns a map series of appropriate type.\r\n\t *\r\n\t * @return {MapSeries} Map series\r\n\t */\r\n\tprotected createSeries(): this[\"_seriesType\"] {\r\n\t\treturn new MapSeries();\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * [deltaLatitude description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param {number} value [description]\r\n\t */\r\n\r\n\t/*public set deltaLatitude(value: number) {\r\n\t\tthis.setPropertyValue(\"deltaLatitude\", $geo.wrapAngleTo180(value));\r\n\t\tthis.invalidateProjection();\r\n\t}\r\n*/\r\n\t/**\r\n\t * @return {number} [description]\r\n\t */\r\n\t/*\r\n public get deltaLatitude(): number {\r\n\t return this.getPropertyValue(\"deltaLatitude\");\r\n }*/\r\n\r\n\t/**\r\n\t * [deltaLongitude description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param {number} value [description]\r\n\t */\r\n\tpublic set deltaLongitude(value: number) {\r\n\t\tthis.setPropertyValue(\"deltaLongitude\", $geo.wrapAngleTo180(value));\r\n\t\tthis.invalidateProjection();\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} [description]\r\n\t */\r\n\tpublic get deltaLongitude(): number {\r\n\t\treturn this.getPropertyValue(\"deltaLongitude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates projection, causing all series to be redrawn.\r\n\t */\r\n\tprotected invalidateProjection() {\r\n\t\t//\t\tthis.projection.deltaLatitude = this.deltaLatitude;\r\n\t\tthis.projection.deltaLongitude = this.deltaLongitude;\r\n\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tseries.invalidate();\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {object}  config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\t// Instantiate projection\r\n\t\tif ($type.hasValue(config[\"projection\"]) && $type.isString(config[\"projection\"])) {\r\n\t\t\tconfig[\"projection\"] = this.createClassInstance(config[\"projection\"]);\r\n\t\t}\r\n\r\n\t\t// Set up small map\r\n\t\tif ($type.hasValue(config.smallMap) && !$type.hasValue(config.smallMap.type)) {\r\n\t\t\tconfig.smallMap.type = \"SmallMap\";\r\n\t\t}\r\n\r\n\t\t// Set up zoom control\r\n\t\tif ($type.hasValue(config.zoomControl) && !$type.hasValue(config.zoomControl.type)) {\r\n\t\t\tconfig.zoomControl.type = \"ZoomControl\";\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n\r\n\t/**\r\n * This function is used to sort element's JSON config properties, so that\r\n * some properties that absolutely need to be processed last, can be put at\r\n * the end.\r\n *\r\n * @ignore Exclude from docs\r\n * @param  {string}  a  Element 1\r\n * @param  {string}  b  Element 2\r\n * @return {number}     Sorting number\r\n */\r\n\tprotected configOrder(a: string, b: string): Ordering {\r\n\t\tif (a == b) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t// Must come last\r\n\t\telse if (a == \"series\") {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\telse if (b == \"series\") {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn super.configOrder(a, b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `projection` to \"as is\" fields.\r\n\t *\r\n\t * @param  {string}   field  Field name\r\n\t * @return {boolean}         Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"projection\" || super.asIs(field);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapChart\"] = MapChart;\r\n\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/types/MapChart.ts","/**\r\n * Map line module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../../core/Container\";\r\nimport { SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapLine } from \"./MapLine\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { system } from \"../../core/System\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapLineObject]].\r\n */\r\nexport interface IMapLineObjectProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * [number description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number}\r\n\t */\r\n\tposition?: number;\r\n\r\n\t/**\r\n\t * [boolean description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {boolean}\r\n\t */\r\n\tadjustRotation?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[MapLineObject]].\r\n */\r\nexport interface IMapLineObjectEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapLineObject]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapLineObjectAdapters extends IContainerAdapters, IMapLineObjectProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a line on the map.\r\n * \r\n * @see {@link IMapLineObjectEvents} for a list of available events\r\n * @see {@link IMapLineObjectAdapters} for a list of available Adapters\r\n */\r\nexport class MapLineObject extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineObjectProperties}\r\n\t */\r\n\tpublic _properties: IMapLineObjectProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapLineObjectAdapters}\r\n\t */\r\n\tpublic _adapter: IMapLineObjectAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapLineObject, IMapLineObjectEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapLineObject, IMapLineObjectEvents>>;\r\n\r\n\t/**\r\n\t * [mapLine description]\r\n\t *\r\n\t * @todo Description\r\n\t * @todo Review if necessary (same as parent)\r\n\t * @type {MapLine}\r\n\t */\r\n\tpublic mapLine: MapLine;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.adjustRotation = true;\r\n\t\tthis.className = \"MapLineObject\";\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.layout = \"none\";\r\n\t\tthis.cloneChildren = true;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates element's position.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validatePosition() {\r\n\t\tif (this.mapLine) {\r\n\t\t\tlet point: IOrientationPoint = this.mapLine.positionToPoint(this.position);\r\n\t\t\tthis.x = point.x;\r\n\t\t\tthis.y = point.y;\r\n\r\n\t\t\tif (this.adjustRotation) {\r\n\t\t\t\tthis.rotation = point.angle;\r\n\t\t\t}\r\n\r\n\t\t\tlet dataItem = this.mapLine.dataItem;\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet series = this.mapLine.dataItem.component;\r\n\t\t\t\tthis.scale = 1 / series.scale;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.validatePosition();\r\n\t}\r\n\r\n\t/**\r\n\t * [position description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param {number} value [description]\r\n\t */\r\n\tpublic set position(value: number) {\r\n\t\tthis.setPropertyValue(\"position\", value, false, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number} [description]\r\n\t */\r\n\tpublic get position(): number {\r\n\t\treturn this.getPropertyValue(\"position\");\r\n\t}\r\n\r\n\t/**\r\n\t * [adjustRotation description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param {boolean} value [description]\r\n\t */\r\n\tpublic set adjustRotation(value: boolean) {\r\n\t\tthis.setPropertyValue(\"adjustRotation\", value, false, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {boolean} [description]\r\n\t */\r\n\tpublic get adjustRotation(): boolean {\r\n\t\treturn this.getPropertyValue(\"adjustRotation\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapLineObject\"] = MapLineObject;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapLineObject.ts","/**\r\n * Map polygon series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapSeries, MapSeriesDataItem, GEOJSONGeometry, IMapSeriesProperties, IMapSeriesDataFields, IMapSeriesAdapters, IMapSeriesEvents } from \"./MapSeries\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapPolygon } from \"./MapPolygon\";\r\nimport { ListTemplate } from \"../../core/utils/List\";\r\nimport { IMapDataObject, IMapPolygonDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $colors from \"../../core/utils/Colors\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapPolygonSeries]]\r\n * @see {@link DataItem}\r\n */\r\nexport class MapPolygonSeriesDataItem extends MapSeriesDataItem {\r\n\r\n\t/**\r\n\t * A [[MapPolygon]] element related to this data item.\r\n\t * \r\n\t * @type {MapPolygon}\r\n\t */\r\n\tprotected _mapPolygon: MapPolygon;\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a single polygon.\r\n\t *\r\n\t * @type {number[][][]}\r\n\t */\r\n\tprotected _polygon: number[][][];\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-part polygon.\r\n\t *\r\n\t * @type {number[][][][]}\r\n\t */\r\n\tprotected _multiPolygon: number[][][][];\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a single polygon.\r\n\t *\r\n\t * @type {IGeoPoint[][]}\r\n\t */\r\n\tprotected _geoPolygon: IGeoPoint[][];\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a multi-part polygon.\r\n\t *\r\n\t * @type {IGeoPoint[][][]}\r\n\t */\r\n\tprotected _multiGeoPolygon: IGeoPoint[][][];\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for\r\n\t * @type {MapPolygonSeries}\r\n\t */\r\n\tpublic _component: MapPolygonSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapPolygonSeriesDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapPolygon]] element related to this data item.\r\n\t *\r\n\t * @readonly\r\n\t * @return {MapPolygon} Element\r\n\t */\r\n\tpublic get mapPolygon(): MapPolygon {\r\n\t\tif (!this._mapPolygon) {\r\n\t\t\tthis._mapPolygon = this.component.mapPolygons.create();\r\n\t\t\tthis.addSprite(this._mapPolygon);\r\n\t\t}\r\n\t\treturn this._mapPolygon;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a single polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   [ \r\n\t *     [ 100, 150 ],\r\n\t *     [ 120, 200 ],\r\n\t *     [ 150, 200 ],\r\n\t *     [ 170, 240 ],\r\n\t *     [ 100, 150 ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t * \r\n\t * @param {number[][][]}  polygon  Coordinates\r\n\t */\r\n\tpublic set polygon(polygon: number[][][]) {\r\n\t\tthis._polygon = polygon;\r\n\t\tthis.multiGeoPolygon = $mapUtils.multiPolygonToGeo([polygon]);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number[]} Coordinates\r\n\t */\r\n\tpublic get polygon(): number[][][] {\r\n\t\treturn this._polygon;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Part 1\r\n\t *   [\r\n\t *     [ \r\n\t *       [ 100, 150 ],\r\n\t *       [ 120, 200 ],\r\n\t *       [ 150, 220 ],\r\n\t *       [ 170, 240 ],\r\n\t *       [ 100, 150 ]\r\n\t *     ]\r\n\t *   ],\r\n\t *\r\n\t *   // Part 2\r\n\t *   [\r\n\t *     [ \r\n\t *       [ 300, 350 ],\r\n\t *       [ 320, 400 ],\r\n\t *       [ 350, 420 ],\r\n\t *       [ 370, 440 ],\r\n\t *       [ 300, 350 ]\r\n\t *     ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t * \r\n\t * @param {number[][][]}  multiPolygon  Coordinates\r\n\t */\r\n\tpublic set multiPolygon(multiPolygon: number[][][][]) {\r\n\t\tthis._multiPolygon = multiPolygon;\r\n\t\tthis.multiGeoPolygon = $mapUtils.multiPolygonToGeo(multiPolygon);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number[]} Coordinates\r\n\t */\r\n\tpublic get multiPolygon(): number[][][][] {\r\n\t\treturn this._multiPolygon;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a single polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   [\r\n\t *     { latitude: -10.0, longitude: -10.0 },\r\n\t *     { latitude: 10.0, longitude: -10.0 },\r\n\t *     { latitude: 10.0, longitude: 10.0 },\r\n\t *     { latitude: -10.0, longitude: -10.0 }\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.6} GeoJSON Polygon reference\r\n\t * @param {IGeoPoint[][]}  geoPolygon  Coordinates\r\n\t */\r\n\tpublic set geoPolygon(geoPolygon: IGeoPoint[][]) {\r\n\t\tthis._geoPolygon = geoPolygon;\r\n\t\tthis.multiGeoPolygon = [geoPolygon];\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} Coordinates\r\n\t */\r\n\tpublic get geoPolygon(): IGeoPoint[][] {\r\n\t\treturn this._geoPolygon;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of lat/long coordinates for a multi-part polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   [\r\n\t *     [\r\n\t *       { longitude: 180.0, latitude: 40.0 },\r\n\t *       { longitude: 180.0, latitude: 50.0 },\r\n\t *       { longitude: 170.0, latitude: 50.0 },\r\n\t *       { longitude: 170.0, latitude: 40.0 },\r\n\t *       { longitude: 180.0, latitude: 40.0 }\r\n\t *     ]\r\n\t *   ],\r\n\t *   [\r\n\t *     [\r\n\t *       { longitude: -170.0, latitude: 40.0 },\r\n\t *       { longitude: -170.0, latitude: 50.0 },\r\n\t *       { longitude: -180.0, latitude: 50.0 },\r\n\t *       { longitude: -180.0, latitude: 40.0 },\r\n\t *       { longitude: -170.0, latitude: 40.0 }\r\n\t *     ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.7} GeoJSON MultiPolygon reference\r\n\t * @param {IGeoPoint[][][]}  multiGeoPolygon  Coordinates\r\n\t */\r\n\tpublic set multiGeoPolygon(multiGeoPolygon: IGeoPoint[][][]) {\r\n\t\tthis._multiGeoPolygon = multiGeoPolygon;\r\n\t\tthis.updateAreaExtremes(multiGeoPolygon);\r\n\t\tthis.mapPolygon.multiGeoPolygon = this._multiGeoPolygon;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint[]} Coordinates\r\n\t */\r\n\tpublic get multiGeoPolygon(): IGeoPoint[][][] {\r\n\t\treturn this._multiGeoPolygon;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the item's bounding coordinates: coordinates of the East, West,\r\n\t * North, and South-most points.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {IGeoPoint[]}  geoPoints  Points of the element\r\n\t */\r\n\tpublic updateAreaExtremes(multiGeoPolygon: IGeoPoint[][][]): void {\r\n\t\tfor (let i = 0; i < multiGeoPolygon.length; i++) {\r\n\t\t\tlet geoPolygon: IGeoPoint[][] = multiGeoPolygon[i];\r\n\t\t\tlet surface: IGeoPoint[] = geoPolygon[0];\r\n\t\t\tthis.updateExtremes(surface);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[MapPolygonSeries]].\r\n */\r\nexport interface IMapPolygonSeriesDataFields extends IMapSeriesDataFields {\r\n\r\n\t/**\r\n\t * Field name that holds polygon pixels.\r\n\t * \r\n\t * @type {string}\r\n\t */\r\n\tpolygon?: string;\r\n\r\n\t/**\r\n\t * Field name that holds multi-polygon pixels.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiPolygon?: string;\r\n\r\n\t/**\r\n\t * Field name that holds polygon data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tgeoPolygon?: string;\r\n\r\n\t/**\r\n\t * Field name that holds poly-polygon data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiGeoPolygon?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[MapPolygonSeries]].\r\n */\r\nexport interface IMapPolygonSeriesProperties extends IMapSeriesProperties { }\r\n\r\n/**\r\n * Defines events for [[MapPolygonSeries]].\r\n */\r\nexport interface IMapPolygonSeriesEvents extends IMapSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapPolygonSeries]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapPolygonSeriesAdapters extends IMapSeriesAdapters, IMapPolygonSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A series of map polygon elements.\r\n * \r\n * @see {@link IMapPolygonSeriesEvents} for a list of available Events\r\n * @see {@link IMapPolygonSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapPolygonSeries extends MapSeries {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapPolygonSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapPolygonSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapPolygonSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapPolygonSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapPolygonSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapPolygonSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapPolygonSeries, IMapPolygonSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapPolygonSeries, IMapPolygonSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapPolygonSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapPolygonSeriesDataItem;\r\n\r\n\t/**\r\n\t * A related chart/map object, this element is drawn on.\r\n\t * \r\n\t * @type {MapChart}\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\t/**\r\n\t * A list of map polygons in the series.\r\n\t * \r\n\t * @type {ListTemplate<MapImage>}\r\n\t */\r\n\tprotected _mapPolygons: ListTemplate<MapPolygon>;\r\n\r\n\r\n\t/**\r\n\t * A function which fills polygons with intermediate color between minColor and maxColor if dataItem has value\r\n\t *\r\n\t * @todo Description\r\n\t * @type {function} \r\n\t */\r\n\tpublic fillRule: (polygon: MapPolygon) => any = function(polygon: MapPolygon) {\r\n\t\tlet dataItem = polygon.dataItem;\r\n\r\n\t\tif (dataItem && dataItem.value) {\t\t\t\r\n\t\t\tlet series = dataItem.component;\r\n\t\t\tif($type.hasValue(series.minColor) &&  $type.hasValue(series.maxColor) && $type.isNumber(series.minValue) && $type.isNumber(series.maxValue)){\r\n\t\t\t\tlet percent = (dataItem.value - series.minValue) / (series.maxValue - series.minValue);\r\n\t\t\t\tpolygon.fill = $colors.interpolate(series.minColor, series.maxColor, percent);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\r\n\t\tthis.parsingStepDuration = 5000; // to avoid some extra redrawing\r\n\r\n\t\tthis.className = \"MapPolygonSeries\";\r\n\r\n\t\t// Set data fields\r\n\t\tthis.dataFields.multiPolygon = \"multiPolygon\";\r\n\t\tthis.dataFields.polygon = \"polygon\";\r\n\r\n\t\tthis.dataFields.geoPolygon = \"geoPolygon\";\r\n\t\tthis.dataFields.multiGeoPolygon = \"multiGeoPolygon\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t * \r\n\t * @see {@link DataItem}\r\n\t * @return {MapPolygonSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapPolygonSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic clearPolygons() {\r\n\t\t$iter.each(this.mapPolygons.iterator(), (mapPolygon) => {\r\n\t\t\tmapPolygon.polygon.dispose();\r\n\t\t\tmapPolygon.dispose();\r\n\t\t})\r\n\t\tthis.mapPolygons.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected processIncExc(){\r\n\t\tthis.clearPolygons();\r\n\t\tsuper.processIncExc();\t\t\r\n\t}\t\r\n\r\n\t/**\r\n\t * (Re)validates series data, effectively causing the whole series to be\r\n\t * redrawn.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tif (this.data.length > 0 && this._parseDataFrom == 0) {\r\n\t\t\tthis.clearPolygons();\r\n\t\t}\r\n\r\n\t\tthis.west = null;\r\n\t\tthis.east = null;\r\n\t\tthis.north = null;\r\n\t\tthis.south = null;\r\n\r\n\t\t// process geoJSON and created map objects\r\n\t\tif (this.getDataFromJSON) {\r\n\t\t\tlet geoJSON: any = this.chart.geoJSON;\r\n\t\t\tif (geoJSON) {\r\n\r\n\t\t\t\tlet features: any[];\r\n\r\n\t\t\t\tif (geoJSON.type == \"FeatureCollection\") {\r\n\t\t\t\t\tfeatures = geoJSON.features;\r\n\t\t\t\t}\r\n\t\t\t\telse if (geoJSON.type == \"Feature\") {\r\n\t\t\t\t\tfeatures = [geoJSON];\r\n\t\t\t\t}\r\n\t\t\t\telse if ([\"Point\", \"LineString\", \"Polygon\", \"MultiPoint\", \"MultiLineString\", \"MultiPolygon\"].indexOf(geoJSON.type) != -1) {\r\n\t\t\t\t\tfeatures = [{ geometry: geoJSON }];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"nothing found in geoJSON\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (features) {\r\n\t\t\t\t\tfor (let i = 0; i < features.length; i++) {\r\n\r\n\t\t\t\t\t\tlet feature: any = features[i];\r\n\t\t\t\t\t\tlet geometry: any = feature.geometry;\r\n\t\t\t\t\t\tif (geometry) {\r\n\t\t\t\t\t\t\tlet type: GEOJSONGeometry = <GEOJSONGeometry>geometry.type;\r\n\t\t\t\t\t\t\tlet id: string = feature.id;\r\n\r\n\t\t\t\t\t\t\tif (type == \"Polygon\" || type == \"MultiPolygon\") {\r\n\r\n\t\t\t\t\t\t\t\tif (!this.checkInclude(this.include, this.exclude, id)) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet coordinates: any[] = geometry.coordinates;\r\n\r\n\t\t\t\t\t\t\t\tif (coordinates) {\r\n\t\t\t\t\t\t\t\t\t// make the same as MultiPolygon\r\n\t\t\t\t\t\t\t\t\tif (type == \"Polygon\") {\r\n\t\t\t\t\t\t\t\t\t\tcoordinates = [coordinates];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// find data object in user-provided data\r\n\t\t\t\t\t\t\t\tlet dataObject: IMapPolygonDataObject = $array.find(this.data, (value, i) => {\r\n\t\t\t\t\t\t\t\t\treturn value.id == id;\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\r\n\t\t\t\t\t\t\t\t// create one if not found\r\n\t\t\t\t\t\t\t\tif (!dataObject) {\r\n\t\t\t\t\t\t\t\t\tdataObject = { multiPolygon: coordinates, id: id };\r\n\t\t\t\t\t\t\t\t\tthis.data.push(dataObject);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// in case found\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t// if user-provided object doesn't have points data provided in any way:\r\n\t\t\t\t\t\t\t\t\tif (!dataObject.multiPolygon) {\r\n\t\t\t\t\t\t\t\t\t\tdataObject.multiPolygon = coordinates;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// copy properties data to datacontext\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(feature.properties, dataObject);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.validateData();\r\n\r\n\t\t// if data is parsed in chunks, polygon list is corrupted, fix it here\r\n\t\t$iter.each(this.dataItems.iterator(), (dataItem) => {\r\n\t\t\tthis.mapPolygons.moveValue(dataItem.mapPolygon);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the series\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tsuper.validate();\r\n\r\n\t\t//console.log(this.uid, this.mapPolygons.length);\r\n\t\t$iter.each(this.mapPolygons.iterator(), (mapPolygon) => {\r\n\t\t\tmapPolygon.validate();\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * List of polygon elements in the series.\r\n\t * \r\n\t * @return {ListTemplate<MapPolygon>} Polygon list\r\n\t */\r\n\tpublic get mapPolygons(): ListTemplate<MapPolygon> {\r\n\r\n\t\tif (!this._mapPolygons) {\r\n\t\t\tlet polygonTemplate: MapPolygon = new MapPolygon();\r\n\r\n\t\t\tlet mapPolygons: ListTemplate<MapPolygon> = new ListTemplate<MapPolygon>(polygonTemplate);\r\n\t\t\tmapPolygons.template.focusable = true;\r\n\t\t\tmapPolygons.events.on(\"insert\", this.handleObjectAdded, this);\r\n\t\t\tthis._mapPolygons = mapPolygons;\r\n\t\t}\r\n\r\n\t\treturn this._mapPolygons;\r\n\t}\r\n\r\n\t/**\r\n\t * returns MapPolygon by id in geoJSON file\r\n\t * @param {string} polygon id\r\n\t * @return {MapPolygon}\r\n\t */\r\n\tpublic getPolygonById(id: string): MapPolygon {\r\n\t\treturn $iter.find(this.mapPolygons.iterator(), (mapPolygon) => {\r\n\t\t\tlet dataContext: any = mapPolygon.dataItem.dataContext;\r\n\t\t\treturn dataContext.id == id;\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapPolygonSeries\"] = MapPolygonSeries;\r\nsystem.registeredClasses[\"MapPolygonSeriesDataItem\"] = MapPolygonSeriesDataItem;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapPolygonSeries.ts","/**\r\n * Map spline series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapLineSeries, MapLineSeriesDataItem, IMapLineSeriesProperties, IMapLineSeriesDataFields, IMapLineSeriesAdapters, IMapLineSeriesEvents } from \"./MapLineSeries\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart, MapLineType } from \"../types/MapChart\";\r\nimport { MapLine } from \"./MapLine\";\r\nimport { MapSpline } from \"./MapSpline\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { IMapDataObject, IMapPolygonDataObject, IMapLineDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $array from \"../../core/utils/Array\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapSplineSeries]]\r\n * @see {@link DataItem}\r\n */\r\nexport class MapSplineSeriesDataItem extends MapLineSeriesDataItem {\r\n\r\n\t/**\r\n\t * A [[MapSpline]] element related to this data item.\r\n\t * \r\n\t * @type {MapSpline}\r\n\t */\r\n\tprotected _mapLine: MapSpline;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for\r\n\t * @type {Component}\r\n\t */\r\n\tpublic _component: MapSplineSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSplineSeriesDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapSpline]] element related to this data item.\r\n\t * \r\n\t * @return {MapSpline} Element\r\n\t */\r\n\tpublic get mapLine(): MapSpline {\r\n\t\tif (!this._mapLine) {\r\n\t\t\tthis._mapLine = this.component.mapLines.create(MapSpline);\r\n\t\t\tthis.addSprite(this._mapLine);\r\n\t\t}\r\n\t\treturn this._mapLine;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[MapSplineSeries]].\r\n */\r\nexport interface IMapSplineSeriesDataFields extends IMapLineSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[MapSplineSeries]].\r\n */\r\nexport interface IMapSplineSeriesProperties extends IMapLineSeriesProperties { }\r\n\r\n/**\r\n * Defines events for [[MapSplineSeries]].\r\n */\r\nexport interface IMapSplineSeriesEvents extends IMapLineSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapSplineSeries]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapSplineSeriesAdapters extends IMapLineSeriesAdapters, IMapSplineSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A series of map spline elements.\r\n * \r\n * @see {@link IMapSplineSeriesEvents} for a list of available Events\r\n * @see {@link IMapSplineSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapSplineSeries extends MapLineSeries {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSplineSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapSplineSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSplineSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapSplineSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapSplineSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapSplineSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapSplineSeries, IMapSplineSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapSplineSeries, IMapSplineSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapSplineSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapSplineSeriesDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the line items in this series.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapSpline}\r\n\t */\r\n\tpublic _mapLine: MapSpline;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSplineSeries\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t * \r\n\t * @see {@link DataItem}\r\n\t * @return {MapSplineSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapSplineSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new line instance of suitable type.\r\n\t * \r\n\t * @return {MapSpline} New line\r\n\t */\r\n\tprotected createLine(): this[\"_mapLine\"] {\r\n\t\treturn new MapSpline();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapSplineSeries\"] = MapSplineSeries;\r\nsystem.registeredClasses[\"MapSplineSeriesDataItem\"] = MapSplineSeriesDataItem;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapSplineSeries.ts","/**\r\n * Map image series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapSeries, MapSeriesDataItem, GEOJSONGeometry, IMapSeriesProperties, IMapSeriesDataFields, IMapSeriesAdapters, IMapSeriesEvents } from \"./MapSeries\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart, MapLineType } from \"../types/MapChart\";\r\nimport { MapImage } from \"./MapImage\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { IMapDataObject, IMapImageDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapImageSeries]]\r\n * @see {@link DataItem}\r\n */\r\nexport class MapImageSeriesDataItem extends MapSeriesDataItem {\r\n\r\n\t/**\r\n\t * A [[MapImage]] element related to this data item.\r\n\t * \r\n\t * @type {MapImage}\r\n\t */\r\n\tprotected _mapImage: MapImage;\r\n\r\n\t/**\r\n\t * [_point description]\r\n\t *\r\n\t * @todo Description\r\n\t * @type {number[]}\r\n\t */\r\n\tprotected _point: number[];\r\n\r\n\t/**\r\n\t * Geographical coordinates image is placed at.\r\n\t * \r\n\t * @type {IGeoPoint}\r\n\t */\r\n\tprotected _geoPoint: IGeoPoint;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for\r\n\t * @type {Component}\r\n\t */\r\n\tpublic _component: MapImageSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapImageSeriesDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapImage]] element related to this data item.\r\n\t * \r\n\t * @return {MapImage} Element\r\n\t */\r\n\tpublic get mapImage(): MapImage {\r\n\t\tif (!this._mapImage) {\r\n\t\t\tthis._mapImage = this.component.mapImages.create();\r\n\t\t\tthis.addSprite(this._mapImage);\r\n\t\t}\r\n\t\treturn this._mapImage;\r\n\t}\r\n\r\n\t/**\r\n\t * [point description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param {number[]} point [description]\r\n\t */\r\n\tpublic set point(point: number[]) {\r\n\t\tthis._point = point;\r\n\t\tthis.geoPoint = $mapUtils.pointToGeo(point);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number[]} [description]\r\n\t */\r\n\tpublic get point(): number[] {\r\n\t\treturn this._point;\r\n\t}\r\n\r\n\t/**\r\n\t * Geographical coordinates (lat/long) image is placed at.\r\n\t * \r\n\t * @param {IGeoPoint} geoPoint Image coordinates\r\n\t */\r\n\tpublic set geoPoint(geoPoint: IGeoPoint) {\r\n\t\tthis._geoPoint = geoPoint;\r\n\t\tthis.updateExtremes([this._geoPoint]);\r\n\t\tthis.mapImage.latitude = this._geoPoint.latitude;\r\n\t\tthis.mapImage.longitude = this._geoPoint.longitude;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {IGeoPoint} Image coordinates\r\n\t */\r\n\tpublic get geoPoint(): IGeoPoint {\r\n\t\treturn this._geoPoint;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[MapImageSeries]].\r\n */\r\nexport interface IMapImageSeriesDataFields extends IMapSeriesDataFields {\r\n\r\n\t/**\r\n\t * Field name that holds image point data in pixels.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tpoint?: string;\r\n\r\n\t/**\r\n\t * Field name that holds multi-image point data in pixels.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiPoint?: string;\r\n\r\n\t/**\r\n\t * Field name that holds image point data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tgeoPoint?: string;\r\n\r\n\t/**\r\n\t * Field name that holds multi-image point data in Geo coordinates.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tmultiGeoPoint?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[MapImageSeries]].\r\n */\r\nexport interface IMapImageSeriesProperties extends IMapSeriesProperties { }\r\n\r\n/**\r\n * Defines events for [[MapImageSeries]].\r\n */\r\nexport interface IMapImageSeriesEvents extends IMapSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapImageSeries]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapImageSeriesAdapters extends IMapSeriesAdapters, IMapImageSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A series of map image (marker) elements.\r\n * \r\n * @see {@link IMapImageSeriesEvents} for a list of available Events\r\n * @see {@link IMapImageSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapImageSeries extends MapSeries {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapImageSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapImageSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapImageSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapImageSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapImageSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapImageSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapImageSeries, IMapImageSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapImageSeries, IMapImageSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapImageSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapImageSeriesDataItem;\r\n\r\n\t/**\r\n\t * A related chart/map object, this image is drawn on.\r\n\t * \r\n\t * @type {MapChart}\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\t/**\r\n\t * A list of map images in the series.\r\n\t * \r\n\t * @type {ListTemplate<MapImage>}\r\n\t */\r\n\tprotected _mapImages: ListTemplate<MapImage>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapImageSeries\";\r\n\r\n\t\t// Set data fields\r\n\t\tthis.dataFields.multiPoint = \"multiPoint\";\r\n\t\tthis.dataFields.point = \"point\";\r\n\r\n\t\tthis.dataFields.geoPoint = \"geoPoint\";\r\n\t\tthis.dataFields.multiGeoPoint = \"multiGeoPoint\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t * \r\n\t * @see {@link DataItem}\r\n\t * @return {MapImageSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapImageSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the data of the sries, effectively forcing it to redraw\r\n\t * all of its elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tif (this.data.length > 0) {\r\n\t\t\tthis.mapImages.clear();\r\n\t\t}\r\n\r\n\t\t// process geoJSON and created map objects\r\n\t\tif (this.getDataFromJSON) {\r\n\t\t\tlet geoJSON: any = this.chart.geoJSON;\r\n\t\t\tif (geoJSON) {\r\n\r\n\t\t\t\tlet features: any[];\r\n\r\n\t\t\t\tif (geoJSON.type == \"FeatureCollection\") {\r\n\t\t\t\t\tfeatures = geoJSON.features;\r\n\t\t\t\t}\r\n\t\t\t\telse if (geoJSON.type == \"Feature\") {\r\n\t\t\t\t\tfeatures = [geoJSON];\r\n\t\t\t\t}\r\n\t\t\t\telse if ([\"Point\", \"LineString\", \"Polygon\", \"MultiPoint\", \"MultiLineString\", \"MultiPolygon\"].indexOf(geoJSON.type) != -1) {\r\n\t\t\t\t\tfeatures = [{ geometry: geoJSON }];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"nothing found in geoJSON\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (features) {\r\n\t\t\t\t\tfor (let i = 0; i < features.length; i++) {\r\n\r\n\t\t\t\t\t\tlet feature: any = features[i];\r\n\t\t\t\t\t\tlet geometry: any = feature.geometry;\r\n\t\t\t\t\t\tif (geometry) {\r\n\t\t\t\t\t\t\tlet type: GEOJSONGeometry = <GEOJSONGeometry>geometry.type;\r\n\t\t\t\t\t\t\tlet id: string = feature.id;\r\n\t\t\t\t\t\t\tif (type == \"Point\" || type == \"MultiPoint\") {  // todo: we don't support multipoints at the moment actually\r\n\r\n\t\t\t\t\t\t\t\tif (!this.checkInclude(this.include, this.exclude, id)) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet coordinates: any[] = geometry.coordinates;\r\n\r\n\t\t\t\t\t\t\t\tif (coordinates) {\r\n\t\t\t\t\t\t\t\t\t// make the same as MultiPoint\r\n\t\t\t\t\t\t\t\t\tif (type == \"MultiPoint\") {\r\n\t\t\t\t\t\t\t\t\t\tcoordinates = [coordinates];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet dataObject: IMapImageDataObject = $array.find(this.data, (value, i) => {\r\n\t\t\t\t\t\t\t\t\treturn value.id == id;\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tif (!dataObject) {\r\n\t\t\t\t\t\t\t\t\tdataObject = { multiPoint: coordinates, id: id };\r\n\t\t\t\t\t\t\t\t\tthis.data.push(dataObject);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tif (!dataObject.multiPoint) {\r\n\t\t\t\t\t\t\t\t\t\tdataObject.multiPoint = coordinates;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// copy properties data to datacontext\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(feature.properties, dataObject);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if data is parsed in chunks, images list is corrupted, fix it here\r\n\t\t$iter.each(this.dataItems.iterator(), (dataItem) => {\r\n\t\t\tthis.mapImages.moveValue(dataItem.mapImage);\r\n\t\t});\r\n\r\n\t\tsuper.validateData();\r\n\t}\r\n\r\n\t/**\r\n\t * A list of map images in the series.\r\n\t * \r\n\t * @return {ListTemplate<MapImage>} Map images\r\n\t */\r\n\tpublic get mapImages(): ListTemplate<MapImage> {\r\n\r\n\t\tif (!this._mapImages) {\r\n\t\t\tlet template: MapImage = new MapImage();\r\n\t\t\tlet mapImages = new ListTemplate<MapImage>(template);\r\n\t\t\tmapImages.template.focusable = true;\r\n\t\t\tmapImages.events.on(\"insert\", this.handleObjectAdded, this);\r\n\t\t\tthis._mapImages = mapImages;\r\n\t\t}\r\n\r\n\t\treturn this._mapImages;\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates data element, effectively triggering its redrawal.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param {this[\"_dataItem\"]}  dataItem  Data item\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]) {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\t\tdataItem.mapImage.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the series\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tsuper.validate();\r\n\t\t$iter.each(this.mapImages.iterator(), (mapImage) => {\r\n\t\t\tmapImage.validatePosition();\r\n\t\t})\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapImageSeries\"] = MapImageSeries;\r\nsystem.registeredClasses[\"MapImageSeriesDataItem\"] = MapImageSeriesDataItem;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapImageSeries.ts","/**\r\n * Map arc series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapLineSeries, MapLineSeriesDataItem, IMapLineSeriesProperties, IMapLineSeriesDataFields, IMapLineSeriesAdapters, IMapLineSeriesEvents } from \"./MapLineSeries\";\r\nimport { Sprite, SpriteEventDispatcher, AMEvent } from \"../../core/Sprite\";\r\nimport { MapChart, MapLineType } from \"../types/MapChart\";\r\nimport { MapLine } from \"./MapLine\";\r\nimport { MapArc } from \"./MapArc\";\r\nimport { MapSpline } from \"./MapSpline\";\r\nimport { ListTemplate, IListEvents } from \"../../core/utils/List\";\r\nimport { IMapDataObject, IMapPolygonDataObject, IMapLineDataObject } from \"../types/MapChart\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { system } from \"../../core/System\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapArcSeries]].\r\n * \r\n * @see {@link DataItem}\r\n */\r\nexport class MapArcSeriesDataItem extends MapLineSeriesDataItem {\r\n\r\n\t/**\r\n\t * A [[MapArc]] element related to this data item.\r\n\t * \r\n\t * @type {MapArc}\r\n\t */\r\n\tprotected _mapLine: MapArc;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t * \r\n\t * @type {Component}\r\n\t */\r\n\tpublic _component: MapArcSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapArcSeriesDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapArc]] element related to this data item.\r\n\t * \r\n\t * @return {MapArc} Element\r\n\t */\r\n\tpublic get mapLine(): MapArc {\r\n\t\tif (!this._mapLine) {\r\n\t\t\tthis._mapLine = this.component.mapLines.create(MapArc);\r\n\t\t\tthis.addSprite(this._mapLine);\r\n\t\t}\r\n\t\treturn this._mapLine;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[MapArcSeries]].\r\n */\r\nexport interface IMapArcSeriesDataFields extends IMapLineSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[MapArcSeries]].\r\n */\r\nexport interface IMapArcSeriesProperties extends IMapLineSeriesProperties { }\r\n\r\n/**\r\n * Defines events for [[MapArcSeries]].\r\n */\r\nexport interface IMapArcSeriesEvents extends IMapLineSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapArcSeries]].\r\n * \r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapArcSeriesAdapters extends IMapLineSeriesAdapters, IMapArcSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A series of arc elements. (curved lines)\r\n * \r\n * @see {@link IMapArcSeriesEvents} for a list of available Events\r\n * @see {@link IMapArcSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapArcSeries extends MapLineSeries {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapArcSeriesDataFields}\r\n\t */\r\n\tpublic _dataFields: IMapArcSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t * \r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapArcSeriesProperties}\r\n\t */\r\n\tpublic _properties: IMapArcSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {IMapArcSeriesAdapters}\r\n\t */\r\n\tpublic _adapter: IMapArcSeriesAdapters;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t * \r\n\t * @type {SpriteEventDispatcher<AMEvent<MapArcSeries, IMapArcSeriesEvents>>} Event dispatcher instance\r\n\t */\r\n\tpublic events: SpriteEventDispatcher<AMEvent<MapArcSeries, IMapArcSeriesEvents>>;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapArcSeriesDataItem}\r\n\t */\r\n\tpublic _dataItem: MapArcSeriesDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the line items in this series.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @type {MapArc}\r\n\t */\r\n\tpublic _mapLine: MapArc;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapArcSeries\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t * \r\n\t * @see {@link DataItem}\r\n\t * @return {MapArcSeriesDataItem} Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapArcSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new line instance of suitable type.\r\n\t * \r\n\t * @return {MapArc} New line\r\n\t */\r\n\tprotected createLine(): this[\"_mapLine\"] {\r\n\t\treturn new MapArc();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"MapArcSeries\"] = MapArcSeries;\r\nsystem.registeredClasses[\"MapArcSeriesDataItem\"] = MapArcSeriesDataItem;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/MapArcSeries.ts","/**\r\n * Functionality for Mercator projection\r\n * \r\n * The function(s) below are from D3.js library (https://d3js.org/)\r\n * \r\n * ```\r\n * Copyright 2017 Mike Bostock\r\n * \r\n * Redistribution and use in source and binary forms, with or without \r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice, \r\n *    this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright notice, \r\n *    this list of conditions and the following disclaimer in the documentation \r\n *    and/or other materials provided with the distribution.\r\n * \r\n * 3. Neither the name of the copyright holder nor the names of its \r\n *    contributors may be used to endorse or promote products derived from this \r\n *    software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \r\n * POSSIBILITY OF SUCH DAMAGE.\r\n * ```\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Projection } from \"./Projection\";\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\nimport { IPoint } from \"../../../core/defs/IPoint\";\r\nimport { system } from \"../../../core/System\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\n\r\n/**\r\n * Mercator projection.\r\n */\r\nexport class Mercator extends Projection {\r\n\r\n\t/**\r\n\t * Converts screen coordinates to latitude/longitude in radians\r\n\t * @param  {number}     x  X\r\n\t * @param  {number}     y  Y\r\n\t * @return {IGeoPoint}     Geographical coordinates\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn {\r\n\t\t\tlongitude: x,\r\n\t\t\tlatitude: 2 * Math.atan(Math.exp(y)) - Math.PI / 2\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical coordinates to screen coordinates.\r\n\t * \r\n\t * @param  {number}  lambda  Lambda parameter\r\n\t * @param  {number}  phi     Phi parameter\r\n\t * @return {IPoint}          Screen coordinates\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn {\r\n\t\t\tx: lambda,\r\n\t\t\ty: Math.log(Math.tan((Math.PI / 2 + phi) / 2))\r\n\t\t};\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"Mercator\"] = Mercator;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Mercator.ts","/**\r\n * Functionality for Miller projection\r\n *\r\n * The function(s) below are from D3.js library (https://d3js.org/)\r\n * \r\n * ```\r\n * Copyright 2017 Mike Bostock\r\n * \r\n * Redistribution and use in source and binary forms, with or without \r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice, \r\n *    this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright notice, \r\n *    this list of conditions and the following disclaimer in the documentation \r\n *    and/or other materials provided with the distribution.\r\n * \r\n * 3. Neither the name of the copyright holder nor the names of its \r\n *    contributors may be used to endorse or promote products derived from this \r\n *    software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \r\n * POSSIBILITY OF SUCH DAMAGE.\r\n * ```\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Projection } from \"./Projection\";\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\nimport { IPoint } from \"../../../core/defs/IPoint\";\r\nimport { system } from \"../../../core/System\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\n\r\n/**\r\n * Miller projection.\r\n */\r\nexport class Miller extends Projection {\r\n\r\n\t/**\r\n\t * Converts screen coordinates to latitude/longitude.\r\n\t * \r\n\t * @param  {number}     x  X\r\n\t * @param  {number}     y  Y\r\n\t * @return {IGeoPoint}     Geographical coordinates in radians\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn {\r\n\t\t\tlongitude: x,\r\n\t\t\tlatitude: 2.5 * Math.atan(Math.exp(0.8 * y)) - 0.625 * Math.PI\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical coordinates to screen coordinates.\r\n\t * \r\n\t * @param  {number}  lambda  Lambda parameter\r\n\t * @param  {number}  phi     Phi parameter\r\n\t * @return {IPoint}          Screen coordinates\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn {\r\n\t\t\tx: lambda,\r\n\t\t\ty: 1.25 * Math.log(Math.tan(Math.PI / 4 + 0.4 * phi))\r\n\t\t};\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"Miller\"] = Miller;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Miller.ts","/**\r\n * Functionality for Eckert6 projection\r\n *\r\n * The function(s) below are from D3.js library (https://d3js.org/)\r\n * \r\n * ```\r\n * Copyright 2017 Mike Bostock\r\n * \r\n * Redistribution and use in source and binary forms, with or without \r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice, \r\n *    this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright notice, \r\n *    this list of conditions and the following disclaimer in the documentation \r\n *    and/or other materials provided with the distribution.\r\n * \r\n * 3. Neither the name of the copyright holder nor the names of its \r\n *    contributors may be used to endorse or promote products derived from this \r\n *    software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \r\n * POSSIBILITY OF SUCH DAMAGE.\r\n * ```\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Projection } from \"./Projection\";\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\nimport { IPoint } from \"../../../core/defs/IPoint\";\r\nimport { system } from \"../../../core/System\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\n\r\n/**\r\n * Eckert6 projection.\r\n */\r\nexport class Eckert6 extends Projection {\r\n\r\n\t/**\r\n\t * Converts screen coordinates to latitude/longitude.\r\n\t * \r\n\t * @param  {number}     x  X\r\n\t * @param  {number}     y  Y\r\n\t * @return {IGeoPoint}     Geographical coordinates in radians\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\tlet j = 1 + Math.PI / 2,\r\n\t\t\tk = Math.sqrt(j / 2);\r\n\t\treturn {\r\n\t\t\tlongitude: x * 2 * k / (1 + Math.cos(y *= k)),\r\n\t\t\tlatitude: Math.asin((y + Math.sin(y)) / j)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical coordinates to screen coordinates.\r\n\t * \r\n\t * @param  {number}  lambda  Lambda parameter\r\n\t * @param  {number}  phi     Phi parameter\r\n\t * @return {IPoint}          Screen coordinates\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\tlet k = (1 + Math.PI / 2) * Math.sin(phi);\r\n\t\tfor (let i = 0, delta = Infinity; i < 10 && Math.abs(delta) > 0.00001; i++) {\r\n\t\t\tphi -= delta = (phi + Math.sin(phi) - k) / (1 + Math.cos(phi));\r\n\t\t}\r\n\t\tk = Math.sqrt(2 + Math.PI);\r\n\t\treturn {\r\n\t\t\tx: lambda * (1 + Math.cos(phi)) / k,\r\n\t\t\ty: 2 * phi / k\r\n\t\t};\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"Eckert6\"] = Eckert6;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Eckert6.ts","/**\r\n * Functionality for Mercator projection\r\n * \r\n * The function(s) below are from D3.js library (https://d3js.org/)\r\n * \r\n * ```\r\n * Copyright 2017 Mike Bostock\r\n * \r\n * Redistribution and use in source and binary forms, with or without \r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice, \r\n *    this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright notice, \r\n *    this list of conditions and the following disclaimer in the documentation \r\n *    and/or other materials provided with the distribution.\r\n * \r\n * 3. Neither the name of the copyright holder nor the names of its \r\n *    contributors may be used to endorse or promote products derived from this \r\n *    software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \r\n * POSSIBILITY OF SUCH DAMAGE.\r\n * ```\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Projection } from \"./Projection\";\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\nimport { IGeoRectangle } from \"../../../core/defs/IGeoRectangle\";\r\nimport { IPoint } from \"../../../core/defs/IPoint\";\r\nimport { system } from \"../../../core/System\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\nimport * as $geo from \"../Geo\";\r\n\r\n/**\r\n * Orthographic projection.\r\n */\r\nexport class Orthographic extends Projection {\r\n\r\n\t/**\r\n\t * Converts geographical coordinates to screen coordinates.\r\n\t * \r\n\t * @param  {number}  lambda  Lambda parameter\r\n\t * @param  {number}  phi     Phi parameter\r\n\t * @return {IPoint}          Screen coordinates\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn { x: Math.cos(phi) * Math.sin(lambda), y: Math.sin(phi) };\r\n\t}\r\n\r\n\r\n\tpublic getClipRectangle1(): IGeoPoint[] {\r\n\t\tlet longitude = 90 - this.deltaLongitude;\r\n\t\tlet latitude = -this.deltaLatitude;\r\n\r\n\t\tlet smallNum = 0.00001;\r\n\t\treturn [{ longitude: longitude - 180, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude - 90 }, { longitude: longitude - smallNum, latitude: latitude + 90 }, { longitude: longitude - 180, latitude: latitude + 90 }];\r\n\t}\r\n\r\n\r\n\tpublic getRect1(): IGeoRectangle {\r\n\t\tlet longitude = 90 - this.deltaLongitude;\r\n\t\tlet latitude = -this.deltaLatitude;\r\n\r\n\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude - 180, east: longitude };\r\n\t}\r\n\r\n\tpublic getClipRectangle2(): IGeoPoint[] {\r\n\t\tlet longitude = 90 - this.deltaLongitude;\r\n\t\tlet latitude = -this.deltaLatitude;\r\n\r\n\t\tlet smallNum = 0.00001;\r\n\r\n\t\tlet delta:number;\r\n\r\n\t\tif(longitude > 0){\r\n\t\t\tdelta = -360;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tdelta = 360;\r\n\t\t}\r\n\r\n\t\treturn [{ longitude: smallNum + longitude - 180 + delta, latitude: latitude - 90 }, { longitude: longitude - smallNum + delta, latitude: latitude - 90 }, { longitude: longitude - smallNum + delta, latitude: latitude + 90 }, { longitude: smallNum + longitude - 180 + delta, latitude: latitude + 90 }];\r\n\t}\r\n\r\n\r\n\r\n\tpublic getRect2(): IGeoRectangle {\r\n\t\tlet longitude = 90 - this.deltaLongitude;\r\n\t\tlet latitude = -this.deltaLatitude;\r\n\r\n\t\tlet delta:number;\r\n\r\n\t\tif(longitude > 0){\r\n\t\t\tdelta = -360;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tdelta = 360;\r\n\t\t}\r\n\t\treturn { north: latitude + 90, south: latitude - 90, west: longitude - 180 + delta, east: longitude + delta};\r\n\t}\r\n\r\n\r\n\r\n\tprotected clipGeoArea(geoArea: IGeoPoint[][][]): IGeoPoint[][][] {\r\n\t\tif (!geoArea) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet clippedArea: IGeoPoint[][][] = [];\r\n\r\n\t\tlet clipRectangle1 = this.getClipRectangle1();\r\n\t\tlet clipRectangle2 = this.getClipRectangle2();\r\n\r\n\t\tlet rect1 = this.getRect1();\r\n\t\tlet rect2 = this.getRect2();\r\n\r\n\t\tfor (let i: number = 0; i < geoArea.length; i++) {\r\n\r\n\t\t\tlet surface: IGeoPoint[] = geoArea[i][0];\r\n\t\t\tlet hole: IGeoPoint[] = geoArea[i][1];\r\n\r\n\t\t\tlet clippedAreas: IGeoPoint[][][] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet surfaceRect = this.getExtremes(surface);\r\n\r\n\t\t\t\tif (!this.isInside(surfaceRect, rect1) && !this.isOutside(surfaceRect, rect1)) {\r\n\t\t\t\t\tlet clippedSurface1: IGeoPoint[] = this.clip(surface, clipRectangle1);\r\n\t\t\t\t\tlet clippedHole1: IGeoPoint[] = this.clip(hole, clipRectangle1);\r\n\t\t\t\t\tclippedAreas.push([clippedSurface1, clippedHole1]);\r\n\t\t\t\t}\r\n\t\t\t\telse if(this.isInside(surfaceRect, rect1)) {\r\n\t\t\t\t\tclippedAreas.push([surface, hole]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!this.isInside(surfaceRect, rect2) && !this.isOutside(surfaceRect, rect2)) {\r\n\t\t\t\t\tlet clippedSurface2: IGeoPoint[] = this.clip(surface, clipRectangle2);\r\n\t\t\t\t\tlet clippedHole2: IGeoPoint[] = this.clip(hole, clipRectangle2);\r\n\r\n\t\t\t\t\tclippedAreas.push([clippedSurface2, clippedHole2]);\r\n\t\t\t\t}\r\n\t\t\t\telse if(this.isInside(surfaceRect, rect2)) {\r\n\t\t\t\t\tclippedAreas.push([surface, hole]);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tfor (let area of clippedAreas) {\r\n\t\t\t\tclippedArea.push(area);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let i: number = 0; i < clippedArea.length; i++) {\r\n\r\n\t\t\tlet surface: IGeoPoint[] = clippedArea[i][0];\r\n\t\t\tlet hole: IGeoPoint[] = clippedArea[i][1];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet prevPoint = surface[surface.length - 1];\r\n\r\n\t\t\t\tfor(let i = 0; i < surface.length; i++){\r\n\t\t\t\t\tlet point = surface[i];\r\n\r\n\t\t\t\t\tif($math.round(point.longitude, 4) == $math.round(prevPoint.longitude, 4)){\r\n\t\t\t\t\t\tlet stepCount = Math.abs((prevPoint.latitude - point.latitude) * 2);\r\n\t\t\t\t\t\tlet extraPoints:IGeoPoint[] = [];\r\n\r\n\t\t\t\t\t\tif(stepCount > 1){\r\n\t\t\t\t\t\t\tfor(let s = 1; s < stepCount; s++){\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\textraPoints.push({longitude:prevPoint.longitude, latitude:prevPoint.latitude + (point.latitude - prevPoint.latitude) / stepCount * s})\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tsurface.splice(i, 0, ...extraPoints);\r\n\t\t\t\t\t\t\ti = i + extraPoints.length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\t\t\r\n\r\n\t\t\t\t\tprevPoint = point;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\r\n\t\treturn clippedArea;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n * \r\n * @ignore\r\n */\r\nsystem.registeredClasses[\"Orthographic\"] = Orthographic;\n\n\n// WEBPACK FOOTER //\n// C:/Users/Pauan/Shared Folders/NixOS/amcharts4dev/src/.internal/charts/map/projections/Orthographic.ts"],"sourceRoot":""}