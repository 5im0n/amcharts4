{"version":3,"file":"AsyncPending.js","sourceRoot":"","sources":["../../../../../src/.internal/core/utils/AsyncPending.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * A collection of low-level async operation stuff.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\n\r\n/**\r\n * [Listener description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @type {[type]}\r\n */\r\nexport type Listener = (now: number) => void;\r\n\r\nlet pendingFrame = false;\r\nlet pendingIdle = false;\r\n\r\nconst nextQueue: Array<Listener> = [];\r\nconst readQueue: Array<Listener> = [];\r\nconst writeQueue: Array<Listener> = [];\r\nconst idleQueue: Array<Listener> = [];\r\n\r\n\r\nconst fps = 1000 / 60;\r\n\r\n/**\r\n * [raf description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @type {[type]}\r\n */\r\nexport const raf =\r\n\t(typeof requestAnimationFrame === \"function\"\r\n\t\t? function(fn: () => void): void {\r\n\t\t\trequestAnimationFrame(fn);\r\n\t\t}\r\n\t\t: function(fn: () => void): void {\r\n\t\t\tsetTimeout(fn, fps);\r\n\t\t});\r\n\r\n/**\r\n * [frameLoop description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction frameLoop(): void {\r\n\tconst now = Date.now();\r\n\r\n\r\n\tconst length = nextQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tnextQueue[i](now);\r\n\t}\r\n\r\n\t$array.shiftLeft(nextQueue, length);\r\n\r\n\r\n\tfor (let i = 0; i < readQueue.length; ++i) {\r\n\t\treadQueue[i](now);\r\n\t}\r\n\r\n\treadQueue.length = 0;\r\n\r\n\r\n\tfor (let i = 0; i < writeQueue.length; ++i) {\r\n\t\twriteQueue[i](now);\r\n\t}\r\n\r\n\twriteQueue.length = 0;\r\n\r\n\r\n\tif (nextQueue.length === 0 && readQueue.length === 0) {\r\n\t\tpendingFrame = false;\r\n\r\n\t} else {\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n/**\r\n * [pendFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction pendFrame(): void {\r\n\tif (!pendingFrame) {\r\n\t\tpendingFrame = true;\r\n\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * [nextFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param {Listener} fn [description]\r\n */\r\nexport function nextFrame(fn: Listener): void {\r\n\tnextQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [readFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param {Listener} fn [description]\r\n */\r\nexport function readFrame(fn: Listener): void {\r\n\treadQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [writeFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param {Listener} fn [description]\r\n */\r\nexport function writeFrame(fn: Listener): void {\r\n\twriteQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\ninterface IdleInfo {\r\n\tdidTimeout: boolean;\r\n\ttimeRemaining: () => number;\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\ninterface IdleOptions {\r\n\ttimeout: number;\r\n}\r\n\r\n/**\r\n * [void description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @type {[type]}\r\n */\r\ndeclare const requestIdleCallback: (fn: (info: IdleInfo) => void, options: IdleOptions) => void;\r\n\r\n// Polyfill\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#Falling_back_to_setTimeout\r\nconst requestIdle: typeof requestIdleCallback =\r\n\t(typeof requestIdleCallback === \"function\"\r\n\t\t? requestIdleCallback\r\n\t\t: function(fn: (info: IdleInfo) => void): void {\r\n\t\t\t// TODO is this a good polyfill ?\r\n\t\t\treadFrame(function() {\r\n\t\t\t\tconst startTime = Date.now();\r\n\r\n\t\t\t\tfn({\r\n\t\t\t\t\tdidTimeout: false,\r\n\t\t\t\t\ttimeRemaining: function() {\r\n\t\t\t\t\t\treturn Math.max(0, 50.0 - (Date.now() - startTime));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\r\n/**\r\n * [idleLoop description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param {IdleInfo} info [description]\r\n */\r\nfunction idleLoop(info: IdleInfo): void {\r\n\tconst now = Date.now();\r\n\r\n\tlet i = 0;\r\n\r\n\t// TODO maybe new callbacks should be pushed to the next update tick ?\r\n\twhile (i < idleQueue.length) {\r\n\t\tif (info.didTimeout || info.timeRemaining() > 0) {\r\n\t\t\tidleQueue[i](now);\r\n\t\t\t++i;\r\n\r\n\t\t} else {\r\n\t\t\t$array.shiftLeft(idleQueue, i);\r\n\t\t\t// TODO is his a good timeout ?\r\n\t\t\trequestIdle(idleLoop, { timeout: 50 });\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tidleQueue.length = 0;\r\n\tpendingIdle = false;\r\n}\r\n\r\n\r\n/*export function whenIdle(fn: Listener): void {\r\n\tidleQueue.push(fn);\r\n\r\n\tif (!pendingIdle) {\r\n\t\tpendingIdle = true;\r\n\t\t// TODO is his a good timeout ?\r\n\t\trequestIdle(idleLoop, { timeout: 50 });\r\n\t}\r\n}*/\r\n\r\n/**\r\n * [whenIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param {Listener} fn [description]\r\n */\r\nexport function whenIdle(fn: Listener): void {\r\n\tidleQueue.push(fn);\r\n}\r\n\r\n\r\n\r\n/**\r\n * [triggerIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo Maybe don't trigger a callback which was added while in the middle of triggering?\r\n */\r\nexport function triggerIdle(): void {\r\n\tconst now = Date.now();\r\n\r\n\tconst length = idleQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t(<any>idleQueue.shift())(now);\r\n\t}\r\n}"]}